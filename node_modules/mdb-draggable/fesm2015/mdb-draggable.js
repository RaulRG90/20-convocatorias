import { EventEmitter, Directive, ElementRef, Renderer2, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';
import { Subject, merge, fromEvent } from 'rxjs';
import { filter, concatMap, tap, takeUntil, first } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';

class MdbDraggableDirective {
    constructor(el, renderer, document) {
        this.el = el;
        this.renderer = renderer;
        this.document = document;
        this.disabled = false;
        this.resetPosition = false;
        this.snapSensitivity = 50;
        this.lockAxis = null;
        this.autoScroll = true;
        this.scrollSpeed = 25;
        this.scrollSensitivity = 30;
        this.snapToGrid = false;
        this.gridSize = 1;
        this.dragStart = new EventEmitter();
        this.dragEnd = new EventEmitter();
        this.elPos = { x: 0, y: 0 };
        this.draggableEl = this.el.nativeElement;
        this.destroy$ = new Subject();
        this.movable = true;
        this.dragging = false;
    }
    get boundTo() { return this._boundTo; }
    set boundTo(value) {
        if (typeof value === 'string') {
            this._boundTo = this.getHtmlElement(value);
        }
        else {
            this._boundTo = value;
        }
    }
    get handle() { return this._handle; }
    set handle(value) {
        if (typeof value === 'string') {
            this._handle = this.getHtmlElement(value);
            this.draggableEl = this.getHtmlElement(value);
        }
        else {
            this._handle = value;
            this.draggableEl = value;
        }
    }
    _subscribeToEvents() {
        const drag = this.start$
            .pipe(filter((event) => event.button !== 2), concatMap((event) => {
            this.onDragStart(event);
            return this.move$
                .pipe(tap((moveEvent) => {
                this.onDragMove(moveEvent);
            }), takeUntil(this.end$));
        }), takeUntil(this.destroy$));
        const drop = this.start$
            .pipe(concatMap(() => {
            return this.end$
                .pipe(first(), tap(() => {
                this.onDragEnd();
            }));
        }), takeUntil(this.destroy$));
        drag.subscribe();
        drop.subscribe();
    }
    ngOnInit() {
        this.start$ = merge(fromEvent(this.draggableEl, 'mousedown', { passive: false }), fromEvent(this.draggableEl, 'touchstart', { passive: false }));
        this.move$ = merge(fromEvent(this.document, 'mousemove', { passive: false }), fromEvent(this.document, 'touchmove', { passive: false }));
        this.end$ = merge(fromEvent(this.document, 'mouseup', { passive: false }), fromEvent(this.document, 'touchend', { passive: false }));
        this._subscribeToEvents();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    _resetPos() {
        this.elPos.x = 0;
        this.elPos.y = 0;
        this.renderer.setStyle(this.el.nativeElement, 'transition', 'transform ease .5s');
        this._updatePosition();
    }
    getHtmlElement(selector) {
        return this.document.querySelector(selector);
    }
    _measureBoundaries() {
        const viewRect = this.boundTo.getBoundingClientRect();
        const movableClientRect = this.el.nativeElement.getBoundingClientRect();
        this.boundaries = {
            minX: viewRect.left - movableClientRect.left + this.elPos.x,
            maxX: viewRect.right - movableClientRect.right + this.elPos.x,
            minY: viewRect.top - movableClientRect.top + this.elPos.y,
            maxY: viewRect.bottom - movableClientRect.bottom + this.elPos.y
        };
    }
    _applyBoundaries() {
        this.elPos.x = Math.max(this.boundaries.minX, this.elPos.x);
        this.elPos.x = Math.min(this.boundaries.maxX, this.elPos.x);
        this.elPos.y = Math.max(this.boundaries.minY, this.elPos.y);
        this.elPos.y = Math.min(this.boundaries.maxY, this.elPos.y);
    }
    onDragStart(event) {
        event.preventDefault();
        if (event instanceof MouseEvent && event.button === 2) {
            return;
        }
        if (this.resetPosition) {
            this.renderer.removeStyle(this.el.nativeElement, 'transition');
        }
        this.dragging = true;
        if (event.type === 'mousedown') {
            this.startPos = {
                x: event.pageX - this.elPos.x,
                y: event.pageY - this.elPos.y
            };
        }
        else {
            this.startPos = {
                x: event.changedTouches[0].pageX - this.elPos.x,
                y: event.changedTouches[0].pageY - this.elPos.y
            };
        }
        if (this.boundTo) {
            this._measureBoundaries();
        }
        this.dragStart.emit(this.el.nativeElement);
    }
    _updateScrollPos() {
        const elRect = this.el.nativeElement.getBoundingClientRect();
        const height = this.document.documentElement.clientHeight;
        const width = this.document.documentElement.clientWidth;
        if (elRect.top < this.scrollSensitivity) {
            this.document.documentElement.scrollTop -= this.scrollSpeed;
        }
        if (elRect.top + elRect.height > height - this.scrollSensitivity) {
            this.document.documentElement.scrollTop += this.scrollSpeed;
        }
        if (elRect.left < this.scrollSensitivity) {
            this.document.documentElement.scrollLeft -= this.scrollSpeed;
        }
        if (elRect.left + elRect.width > width - this.scrollSensitivity) {
            this.document.documentElement.scrollLeft += this.scrollSpeed;
        }
    }
    onDragMove(event) {
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        if (this.snapToGrid && this.gridSize > 1) {
            if (event.type === 'mousemove') {
                this.elPos.x = Math.round((event.pageX - this.startPos.x) / this.gridSize) * this.gridSize;
                this.elPos.y = Math.round((event.pageY - this.startPos.y) / this.gridSize) * this.gridSize;
            }
            else {
                this.elPos.x = Math.round((event.changedTouches[0].pageX - this.startPos.x) / this.gridSize) * this.gridSize;
                this.elPos.y = Math.round((event.changedTouches[0].pageY - this.startPos.y) / this.gridSize) * this.gridSize;
            }
        }
        else {
            if (event.type === 'mousemove') {
                this.elPos.x = event.pageX - this.startPos.x;
                this.elPos.y = event.pageY - this.startPos.y;
            }
            else {
                this.elPos.x = event.changedTouches[0].pageX - this.startPos.x;
                this.elPos.y = event.changedTouches[0].pageY - this.startPos.y;
            }
        }
        if (this.boundTo) {
            this._applyBoundaries();
        }
        if (this.lockAxis === 'x') {
            this.elPos.y = 0;
        }
        if (this.lockAxis === 'y') {
            this.elPos.x = 0;
        }
        if (this.autoScroll) {
            this._updateScrollPos();
        }
        this._updatePosition();
    }
    onDragEnd() {
        this.dragging = false;
        if (this.resetPosition) {
            this._resetPos();
        }
        this.dragEnd.emit(this.el.nativeElement);
    }
    _updatePosition() {
        requestAnimationFrame(() => {
            const position = `translate(${this.elPos.x}px, ${this.elPos.y}px)`;
            this.renderer.setStyle(this.el.nativeElement, 'transform', position);
        });
    }
}
MdbDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdbDraggable]'
            },] }
];
MdbDraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
MdbDraggableDirective.propDecorators = {
    disabled: [{ type: Input }],
    resetPosition: [{ type: Input }],
    boundTo: [{ type: Input }],
    handle: [{ type: Input }],
    snapSensitivity: [{ type: Input }],
    lockAxis: [{ type: Input }],
    autoScroll: [{ type: Input }],
    scrollSpeed: [{ type: Input }],
    scrollSensitivity: [{ type: Input }],
    snapToGrid: [{ type: Input }],
    gridSize: [{ type: Input }],
    dragStart: [{ type: Output }],
    dragEnd: [{ type: Output }],
    movable: [{ type: HostBinding, args: ['class.mdb-draggable',] }],
    dragging: [{ type: HostBinding, args: ['class.mdb-dragging',] }]
};

class MdbDraggableModule {
}
MdbDraggableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [MdbDraggableDirective],
                imports: [],
                exports: [MdbDraggableDirective]
            },] }
];

/*
 * Public API Surface of mdb-draggable
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbDraggableDirective, MdbDraggableModule };
//# sourceMappingURL=mdb-draggable.js.map
