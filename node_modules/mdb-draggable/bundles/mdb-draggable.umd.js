(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('mdb-draggable', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['mdb-draggable'] = {}, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, core, rxjs, operators, common) { 'use strict';

    var MdbDraggableDirective = /** @class */ (function () {
        function MdbDraggableDirective(el, renderer, document) {
            this.el = el;
            this.renderer = renderer;
            this.document = document;
            this.disabled = false;
            this.resetPosition = false;
            this.snapSensitivity = 50;
            this.lockAxis = null;
            this.autoScroll = true;
            this.scrollSpeed = 25;
            this.scrollSensitivity = 30;
            this.snapToGrid = false;
            this.gridSize = 1;
            this.dragStart = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.elPos = { x: 0, y: 0 };
            this.draggableEl = this.el.nativeElement;
            this.destroy$ = new rxjs.Subject();
            this.movable = true;
            this.dragging = false;
        }
        Object.defineProperty(MdbDraggableDirective.prototype, "boundTo", {
            get: function () { return this._boundTo; },
            set: function (value) {
                if (typeof value === 'string') {
                    this._boundTo = this.getHtmlElement(value);
                }
                else {
                    this._boundTo = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdbDraggableDirective.prototype, "handle", {
            get: function () { return this._handle; },
            set: function (value) {
                if (typeof value === 'string') {
                    this._handle = this.getHtmlElement(value);
                    this.draggableEl = this.getHtmlElement(value);
                }
                else {
                    this._handle = value;
                    this.draggableEl = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        MdbDraggableDirective.prototype._subscribeToEvents = function () {
            var _this = this;
            var drag = this.start$
                .pipe(operators.filter(function (event) { return event.button !== 2; }), operators.concatMap(function (event) {
                _this.onDragStart(event);
                return _this.move$
                    .pipe(operators.tap(function (moveEvent) {
                    _this.onDragMove(moveEvent);
                }), operators.takeUntil(_this.end$));
            }), operators.takeUntil(this.destroy$));
            var drop = this.start$
                .pipe(operators.concatMap(function () {
                return _this.end$
                    .pipe(operators.first(), operators.tap(function () {
                    _this.onDragEnd();
                }));
            }), operators.takeUntil(this.destroy$));
            drag.subscribe();
            drop.subscribe();
        };
        MdbDraggableDirective.prototype.ngOnInit = function () {
            this.start$ = rxjs.merge(rxjs.fromEvent(this.draggableEl, 'mousedown', { passive: false }), rxjs.fromEvent(this.draggableEl, 'touchstart', { passive: false }));
            this.move$ = rxjs.merge(rxjs.fromEvent(this.document, 'mousemove', { passive: false }), rxjs.fromEvent(this.document, 'touchmove', { passive: false }));
            this.end$ = rxjs.merge(rxjs.fromEvent(this.document, 'mouseup', { passive: false }), rxjs.fromEvent(this.document, 'touchend', { passive: false }));
            this._subscribeToEvents();
        };
        MdbDraggableDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        MdbDraggableDirective.prototype._resetPos = function () {
            this.elPos.x = 0;
            this.elPos.y = 0;
            this.renderer.setStyle(this.el.nativeElement, 'transition', 'transform ease .5s');
            this._updatePosition();
        };
        MdbDraggableDirective.prototype.getHtmlElement = function (selector) {
            return this.document.querySelector(selector);
        };
        MdbDraggableDirective.prototype._measureBoundaries = function () {
            var viewRect = this.boundTo.getBoundingClientRect();
            var movableClientRect = this.el.nativeElement.getBoundingClientRect();
            this.boundaries = {
                minX: viewRect.left - movableClientRect.left + this.elPos.x,
                maxX: viewRect.right - movableClientRect.right + this.elPos.x,
                minY: viewRect.top - movableClientRect.top + this.elPos.y,
                maxY: viewRect.bottom - movableClientRect.bottom + this.elPos.y
            };
        };
        MdbDraggableDirective.prototype._applyBoundaries = function () {
            this.elPos.x = Math.max(this.boundaries.minX, this.elPos.x);
            this.elPos.x = Math.min(this.boundaries.maxX, this.elPos.x);
            this.elPos.y = Math.max(this.boundaries.minY, this.elPos.y);
            this.elPos.y = Math.min(this.boundaries.maxY, this.elPos.y);
        };
        MdbDraggableDirective.prototype.onDragStart = function (event) {
            event.preventDefault();
            if (event instanceof MouseEvent && event.button === 2) {
                return;
            }
            if (this.resetPosition) {
                this.renderer.removeStyle(this.el.nativeElement, 'transition');
            }
            this.dragging = true;
            if (event.type === 'mousedown') {
                this.startPos = {
                    x: event.pageX - this.elPos.x,
                    y: event.pageY - this.elPos.y
                };
            }
            else {
                this.startPos = {
                    x: event.changedTouches[0].pageX - this.elPos.x,
                    y: event.changedTouches[0].pageY - this.elPos.y
                };
            }
            if (this.boundTo) {
                this._measureBoundaries();
            }
            this.dragStart.emit(this.el.nativeElement);
        };
        MdbDraggableDirective.prototype._updateScrollPos = function () {
            var elRect = this.el.nativeElement.getBoundingClientRect();
            var height = this.document.documentElement.clientHeight;
            var width = this.document.documentElement.clientWidth;
            if (elRect.top < this.scrollSensitivity) {
                this.document.documentElement.scrollTop -= this.scrollSpeed;
            }
            if (elRect.top + elRect.height > height - this.scrollSensitivity) {
                this.document.documentElement.scrollTop += this.scrollSpeed;
            }
            if (elRect.left < this.scrollSensitivity) {
                this.document.documentElement.scrollLeft -= this.scrollSpeed;
            }
            if (elRect.left + elRect.width > width - this.scrollSensitivity) {
                this.document.documentElement.scrollLeft += this.scrollSpeed;
            }
        };
        MdbDraggableDirective.prototype.onDragMove = function (event) {
            event.preventDefault();
            if (this.disabled) {
                return;
            }
            if (this.snapToGrid && this.gridSize > 1) {
                if (event.type === 'mousemove') {
                    this.elPos.x = Math.round((event.pageX - this.startPos.x) / this.gridSize) * this.gridSize;
                    this.elPos.y = Math.round((event.pageY - this.startPos.y) / this.gridSize) * this.gridSize;
                }
                else {
                    this.elPos.x = Math.round((event.changedTouches[0].pageX - this.startPos.x) / this.gridSize) * this.gridSize;
                    this.elPos.y = Math.round((event.changedTouches[0].pageY - this.startPos.y) / this.gridSize) * this.gridSize;
                }
            }
            else {
                if (event.type === 'mousemove') {
                    this.elPos.x = event.pageX - this.startPos.x;
                    this.elPos.y = event.pageY - this.startPos.y;
                }
                else {
                    this.elPos.x = event.changedTouches[0].pageX - this.startPos.x;
                    this.elPos.y = event.changedTouches[0].pageY - this.startPos.y;
                }
            }
            if (this.boundTo) {
                this._applyBoundaries();
            }
            if (this.lockAxis === 'x') {
                this.elPos.y = 0;
            }
            if (this.lockAxis === 'y') {
                this.elPos.x = 0;
            }
            if (this.autoScroll) {
                this._updateScrollPos();
            }
            this._updatePosition();
        };
        MdbDraggableDirective.prototype.onDragEnd = function () {
            this.dragging = false;
            if (this.resetPosition) {
                this._resetPos();
            }
            this.dragEnd.emit(this.el.nativeElement);
        };
        MdbDraggableDirective.prototype._updatePosition = function () {
            var _this = this;
            requestAnimationFrame(function () {
                var position = "translate(" + _this.elPos.x + "px, " + _this.elPos.y + "px)";
                _this.renderer.setStyle(_this.el.nativeElement, 'transform', position);
            });
        };
        return MdbDraggableDirective;
    }());
    MdbDraggableDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mdbDraggable]'
                },] }
    ];
    MdbDraggableDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    MdbDraggableDirective.propDecorators = {
        disabled: [{ type: core.Input }],
        resetPosition: [{ type: core.Input }],
        boundTo: [{ type: core.Input }],
        handle: [{ type: core.Input }],
        snapSensitivity: [{ type: core.Input }],
        lockAxis: [{ type: core.Input }],
        autoScroll: [{ type: core.Input }],
        scrollSpeed: [{ type: core.Input }],
        scrollSensitivity: [{ type: core.Input }],
        snapToGrid: [{ type: core.Input }],
        gridSize: [{ type: core.Input }],
        dragStart: [{ type: core.Output }],
        dragEnd: [{ type: core.Output }],
        movable: [{ type: core.HostBinding, args: ['class.mdb-draggable',] }],
        dragging: [{ type: core.HostBinding, args: ['class.mdb-dragging',] }]
    };

    var MdbDraggableModule = /** @class */ (function () {
        function MdbDraggableModule() {
        }
        return MdbDraggableModule;
    }());
    MdbDraggableModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [MdbDraggableDirective],
                    imports: [],
                    exports: [MdbDraggableDirective]
                },] }
    ];

    /*
     * Public API Surface of mdb-draggable
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.MdbDraggableDirective = MdbDraggableDirective;
    exports.MdbDraggableModule = MdbDraggableModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=mdb-draggable.umd.js.map
