{"ast":null,"code":"import { EventEmitter, Directive, Renderer2, ElementRef, NgZone, Input, Output, NgModule } from '@angular/core';\nimport { Subject, fromEvent } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nlet MdbTableEditorDirective = /*#__PURE__*/(() => {\n  class MdbTableEditorDirective {\n    constructor(renderer, el, ngZone) {\n      this.renderer = renderer;\n      this.el = el;\n      this.ngZone = ngZone;\n      this.itemsPerPage = 10;\n      this.rowHighlight = new EventEmitter();\n      this.highlightedTableRow = null;\n      this.dataArrayUnmodified = [];\n      this.currentPage = 1;\n      this.nextShouldBeDisabled = false;\n      this.data = [];\n      this.isDesc = true;\n      this._searchKey = '';\n      this._dataArray$ = new Subject();\n      this._iterableDataArray = [];\n      this._iterableDataArray$ = new Subject();\n      this.paginationInfo = {\n        firstItem: 1,\n        lastItem: this.itemsPerPage,\n        allItems: this.dataArrayUnmodified.length,\n        activePage: this.currentPage\n      };\n      this.dataArrayChange().pipe().subscribe(newData => {\n        this.dataArrayUnmodified = newData;\n        setTimeout(() => {\n          this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n          this.data = this.iterableDataArray;\n          this.updatePaginationInfo();\n        }, 0);\n      });\n      this.iterableDataArrayChange().pipe(distinctUntilChanged()).subscribe(() => {\n        if (this.data && this._searchKey.length == 0 && this.currentPage == 1) {\n          this.paginationInfo.firstItem = this.data.findIndex(el => el === this.data[0]) + 1;\n          this.paginationInfo.lastItem = this.data.findIndex(el => el == this.data[this.data.length - 1]) + 1;\n        }\n\n        if (this.iterableDataArray && this.iterableDataArray.findIndex(el => el == this.highlightedTableRow) === -1) {\n          if (this.highlightedTableRow !== null) {\n            this.highlightedTableRow = null;\n            this.rowHighlight.emit(null);\n          }\n        }\n      });\n      const click$ = fromEvent(this.el.nativeElement, 'click');\n      click$.subscribe(event => {\n        // Workaround for situation when fromEvent is not able to emit value from EventEmitter\n        this.ngZone.run(() => {\n          this.markHighlightAndEmit(event);\n        });\n      });\n    }\n\n    set dataArray(data) {\n      this._dataArray = data;\n\n      this._dataArray$.next(this.dataArray);\n    }\n\n    get dataArray() {\n      return this._dataArray;\n    }\n\n    dataArrayChange() {\n      return this._dataArray$;\n    }\n\n    set iterableDataArray(data) {\n      this._iterableDataArray = data;\n\n      this._iterableDataArray$.next(this.iterableDataArray);\n    }\n\n    get iterableDataArray() {\n      return this._iterableDataArray;\n    }\n\n    iterableDataArrayChange() {\n      return this._iterableDataArray$;\n    }\n\n    ngOnChanges(changes) {\n      if (changes['itemsPerPage']) {\n        this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n\n        if (!changes['itemsPerPage'].isFirstChange()) {\n          this.updatePaginationInfo();\n        }\n      }\n    }\n\n    calculatePagesNumber() {\n      return Math.ceil(this.dataArrayUnmodified.length / this.itemsPerPage);\n    }\n\n    updatePaginationInfo() {\n      if (this.dataArray) {\n        const firstAndLastIndexes = {\n          first: this.dataArray.findIndex(el => el === this.iterableDataArray[0]) + 1 || this.iterableDataArray.findIndex(el => el === this.iterableDataArray[0]) + 1,\n          last: this.dataArray.findIndex(el => el === this.iterableDataArray[this.iterableDataArray.length - 1]) + 1 || this.iterableDataArray.findIndex(el => el === this.iterableDataArray[this.iterableDataArray.length - 1]) + 1\n        };\n        this.paginationInfo = {\n          firstItem: firstAndLastIndexes.first,\n          lastItem: firstAndLastIndexes.last,\n          allItems: this.dataArrayUnmodified.length,\n          activePage: this.currentPage\n        };\n      }\n    }\n\n    nextPage(switchToLastPage) {\n      if (this.currentPage < this.calculatePagesNumber()) {\n        if (switchToLastPage) {\n          this.currentPage = this.calculatePagesNumber();\n        } else {\n          this.currentPage++;\n        }\n\n        this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n        this.updatePaginationInfo();\n        const firstAndLastIndexes = {\n          first: this.dataArrayUnmodified.findIndex(el => el == this.iterableDataArray[0]) + 1,\n          last: this.dataArrayUnmodified.findIndex(el => el == this.iterableDataArray[this.iterableDataArray.length - 1]) + 1\n        };\n        this.paginationInfo.firstItem = firstAndLastIndexes.first;\n        this.paginationInfo.lastItem = firstAndLastIndexes.last;\n      }\n    }\n\n    prevPage(switchToFirstPage) {\n      if (this.currentPage > 1) {\n        if (switchToFirstPage) {\n          this.currentPage = 1;\n        } else {\n          this.currentPage--;\n        }\n\n        this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n        this.updatePaginationInfo();\n      }\n\n      const firstAndLastIndexes = {\n        first: this.dataArrayUnmodified.findIndex(el => el == this.iterableDataArray[0]) + 1,\n        last: this.dataArrayUnmodified.findIndex(el => el == this.iterableDataArray[this.iterableDataArray.length - 1]) + 1\n      };\n      this.paginationInfo.firstItem = firstAndLastIndexes.first;\n      this.paginationInfo.lastItem = firstAndLastIndexes.last;\n    }\n\n    disablePrevious() {\n      return this.currentPage === 1;\n    }\n\n    disableNext() {\n      if (this.dataArrayUnmodified) {\n        return this.currentPage >= this.calculatePagesNumber() || this.nextShouldBeDisabled;\n      }\n    }\n\n    filterIterableArray(searchKey) {\n      if (this.dataArray) {\n        const filter = this.dataArray.filter(obj => {\n          return Object.keys(obj).some(key => {\n            if (obj[key] !== null) {\n              return obj[key].toString().toLowerCase().includes(searchKey);\n            }\n          });\n        });\n        this.iterableDataArray = filter.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n        this.nextShouldBeDisabled = this.iterableDataArray.length < this.itemsPerPage;\n        this.updatePaginationInfo();\n        return this.iterableDataArray;\n      }\n    }\n\n    performSearch(searchKey) {\n      this._searchKey = searchKey;\n\n      if (!searchKey && this.dataArray) {\n        this.nextShouldBeDisabled = false;\n        this.data = this.dataArray.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n\n        this._iterableDataArray$.next(this.data);\n\n        return this.dataArray.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);\n      } else {\n        this.data = this.filterIterableArray(searchKey.toLowerCase());\n        return this.filterIterableArray(searchKey.toLowerCase());\n      }\n    }\n\n    sortArray(property) {\n      this.dataArray = this.dataArrayUnmodified.slice();\n      this.isDesc = !this.isDesc; //change the direction\n\n      property = property.replace(/ /g, '_').toLowerCase();\n      const direction = this.isDesc ? 1 : -1;\n      this.dataArray.sort((a, b) => {\n        if (a[property] < b[property]) {\n          return -1 * direction;\n        } else if (a[property] > b[property]) {\n          return 1 * direction;\n        } else {\n          return 0;\n        }\n      });\n    }\n\n    _getClosestEl(el, selector) {\n      for (; el && el !== document; el = el.parentNode) {\n        if (el.matches && el.matches(selector)) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n    markHighlightAndEmit(event) {\n      const tableRow = this._getClosestEl(event.target, 'tr');\n\n      const tbody = this._getClosestEl(event.target, 'tbody');\n\n      if (tbody && event.target) {\n        tbody.childNodes.forEach((row, index) => {\n          if (row === tableRow) {\n            this.highlightedTableRow = this.iterableDataArray[index];\n          }\n\n          if (row !== tableRow) {\n            if (row.classList && row.classList.contains('tr-color-selected')) {\n              this.renderer.removeClass(row, 'tr-color-selected');\n            }\n          }\n        });\n        this.rowHighlight.emit(this.highlightedTableRow);\n        this.renderer.addClass(tableRow, 'tr-color-selected');\n      }\n    }\n\n  }\n\n  MdbTableEditorDirective.ɵfac = function MdbTableEditorDirective_Factory(t) {\n    return new (t || MdbTableEditorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MdbTableEditorDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbTableEditorDirective,\n    selectors: [[\"\", \"mdbTableEditor\", \"\"]],\n    inputs: {\n      itemsPerPage: \"itemsPerPage\"\n    },\n    outputs: {\n      rowHighlight: \"rowHighlight\"\n    },\n    exportAs: [\"mdbEditor\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return MdbTableEditorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbTableEditorModule = /*#__PURE__*/(() => {\n  class MdbTableEditorModule {}\n\n  MdbTableEditorModule.ɵfac = function MdbTableEditorModule_Factory(t) {\n    return new (t || MdbTableEditorModule)();\n  };\n\n  MdbTableEditorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbTableEditorModule\n  });\n  MdbTableEditorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule]]\n  });\n  return MdbTableEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbTableEditorModule, {\n    declarations: function () {\n      return [MdbTableEditorDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdbTableEditorDirective];\n    }\n  });\n})();\n/*\n * Public API Surface of mdb-table-editor\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MdbTableEditorDirective, MdbTableEditorModule }; //# sourceMappingURL=mdb-table-editor.js.map","map":null,"metadata":{},"sourceType":"module"}