{"ast":null,"code":"import { EventEmitter, Directive, ElementRef, Renderer2, Inject, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { Subject, merge, fromEvent } from 'rxjs';\nimport { filter, concatMap, tap, takeUntil, first } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nlet MdbDraggableDirective = /*#__PURE__*/(() => {\n  class MdbDraggableDirective {\n    constructor(el, renderer, document) {\n      this.el = el;\n      this.renderer = renderer;\n      this.document = document;\n      this.disabled = false;\n      this.resetPosition = false;\n      this.snapSensitivity = 50;\n      this.lockAxis = null;\n      this.autoScroll = true;\n      this.scrollSpeed = 25;\n      this.scrollSensitivity = 30;\n      this.snapToGrid = false;\n      this.gridSize = 1;\n      this.dragStart = new EventEmitter();\n      this.dragEnd = new EventEmitter();\n      this.elPos = {\n        x: 0,\n        y: 0\n      };\n      this.draggableEl = this.el.nativeElement;\n      this.destroy$ = new Subject();\n      this.movable = true;\n      this.dragging = false;\n    }\n\n    get boundTo() {\n      return this._boundTo;\n    }\n\n    set boundTo(value) {\n      if (typeof value === 'string') {\n        this._boundTo = this.getHtmlElement(value);\n      } else {\n        this._boundTo = value;\n      }\n    }\n\n    get handle() {\n      return this._handle;\n    }\n\n    set handle(value) {\n      if (typeof value === 'string') {\n        this._handle = this.getHtmlElement(value);\n        this.draggableEl = this.getHtmlElement(value);\n      } else {\n        this._handle = value;\n        this.draggableEl = value;\n      }\n    }\n\n    _subscribeToEvents() {\n      const drag = this.start$.pipe(filter(event => event.button !== 2), concatMap(event => {\n        this.onDragStart(event);\n        return this.move$.pipe(tap(moveEvent => {\n          this.onDragMove(moveEvent);\n        }), takeUntil(this.end$));\n      }), takeUntil(this.destroy$));\n      const drop = this.start$.pipe(concatMap(() => {\n        return this.end$.pipe(first(), tap(() => {\n          this.onDragEnd();\n        }));\n      }), takeUntil(this.destroy$));\n      drag.subscribe();\n      drop.subscribe();\n    }\n\n    ngOnInit() {\n      this.start$ = merge(fromEvent(this.draggableEl, 'mousedown', {\n        passive: false\n      }), fromEvent(this.draggableEl, 'touchstart', {\n        passive: false\n      }));\n      this.move$ = merge(fromEvent(this.document, 'mousemove', {\n        passive: false\n      }), fromEvent(this.document, 'touchmove', {\n        passive: false\n      }));\n      this.end$ = merge(fromEvent(this.document, 'mouseup', {\n        passive: false\n      }), fromEvent(this.document, 'touchend', {\n        passive: false\n      }));\n\n      this._subscribeToEvents();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    _resetPos() {\n      this.elPos.x = 0;\n      this.elPos.y = 0;\n      this.renderer.setStyle(this.el.nativeElement, 'transition', 'transform ease .5s');\n\n      this._updatePosition();\n    }\n\n    getHtmlElement(selector) {\n      return this.document.querySelector(selector);\n    }\n\n    _measureBoundaries() {\n      const viewRect = this.boundTo.getBoundingClientRect();\n      const movableClientRect = this.el.nativeElement.getBoundingClientRect();\n      this.boundaries = {\n        minX: viewRect.left - movableClientRect.left + this.elPos.x,\n        maxX: viewRect.right - movableClientRect.right + this.elPos.x,\n        minY: viewRect.top - movableClientRect.top + this.elPos.y,\n        maxY: viewRect.bottom - movableClientRect.bottom + this.elPos.y\n      };\n    }\n\n    _applyBoundaries() {\n      this.elPos.x = Math.max(this.boundaries.minX, this.elPos.x);\n      this.elPos.x = Math.min(this.boundaries.maxX, this.elPos.x);\n      this.elPos.y = Math.max(this.boundaries.minY, this.elPos.y);\n      this.elPos.y = Math.min(this.boundaries.maxY, this.elPos.y);\n    }\n\n    onDragStart(event) {\n      event.preventDefault();\n\n      if (event instanceof MouseEvent && event.button === 2) {\n        return;\n      }\n\n      if (this.resetPosition) {\n        this.renderer.removeStyle(this.el.nativeElement, 'transition');\n      }\n\n      this.dragging = true;\n\n      if (event.type === 'mousedown') {\n        this.startPos = {\n          x: event.pageX - this.elPos.x,\n          y: event.pageY - this.elPos.y\n        };\n      } else {\n        this.startPos = {\n          x: event.changedTouches[0].pageX - this.elPos.x,\n          y: event.changedTouches[0].pageY - this.elPos.y\n        };\n      }\n\n      if (this.boundTo) {\n        this._measureBoundaries();\n      }\n\n      this.dragStart.emit(this.el.nativeElement);\n    }\n\n    _updateScrollPos() {\n      const elRect = this.el.nativeElement.getBoundingClientRect();\n      const height = this.document.documentElement.clientHeight;\n      const width = this.document.documentElement.clientWidth;\n\n      if (elRect.top < this.scrollSensitivity) {\n        this.document.documentElement.scrollTop -= this.scrollSpeed;\n      }\n\n      if (elRect.top + elRect.height > height - this.scrollSensitivity) {\n        this.document.documentElement.scrollTop += this.scrollSpeed;\n      }\n\n      if (elRect.left < this.scrollSensitivity) {\n        this.document.documentElement.scrollLeft -= this.scrollSpeed;\n      }\n\n      if (elRect.left + elRect.width > width - this.scrollSensitivity) {\n        this.document.documentElement.scrollLeft += this.scrollSpeed;\n      }\n    }\n\n    onDragMove(event) {\n      event.preventDefault();\n\n      if (this.disabled) {\n        return;\n      }\n\n      if (this.snapToGrid && this.gridSize > 1) {\n        if (event.type === 'mousemove') {\n          this.elPos.x = Math.round((event.pageX - this.startPos.x) / this.gridSize) * this.gridSize;\n          this.elPos.y = Math.round((event.pageY - this.startPos.y) / this.gridSize) * this.gridSize;\n        } else {\n          this.elPos.x = Math.round((event.changedTouches[0].pageX - this.startPos.x) / this.gridSize) * this.gridSize;\n          this.elPos.y = Math.round((event.changedTouches[0].pageY - this.startPos.y) / this.gridSize) * this.gridSize;\n        }\n      } else {\n        if (event.type === 'mousemove') {\n          this.elPos.x = event.pageX - this.startPos.x;\n          this.elPos.y = event.pageY - this.startPos.y;\n        } else {\n          this.elPos.x = event.changedTouches[0].pageX - this.startPos.x;\n          this.elPos.y = event.changedTouches[0].pageY - this.startPos.y;\n        }\n      }\n\n      if (this.boundTo) {\n        this._applyBoundaries();\n      }\n\n      if (this.lockAxis === 'x') {\n        this.elPos.y = 0;\n      }\n\n      if (this.lockAxis === 'y') {\n        this.elPos.x = 0;\n      }\n\n      if (this.autoScroll) {\n        this._updateScrollPos();\n      }\n\n      this._updatePosition();\n    }\n\n    onDragEnd() {\n      this.dragging = false;\n\n      if (this.resetPosition) {\n        this._resetPos();\n      }\n\n      this.dragEnd.emit(this.el.nativeElement);\n    }\n\n    _updatePosition() {\n      requestAnimationFrame(() => {\n        const position = `translate(${this.elPos.x}px, ${this.elPos.y}px)`;\n        this.renderer.setStyle(this.el.nativeElement, 'transform', position);\n      });\n    }\n\n  }\n\n  MdbDraggableDirective.ɵfac = function MdbDraggableDirective_Factory(t) {\n    return new (t || MdbDraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  MdbDraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbDraggableDirective,\n    selectors: [[\"\", \"mdbDraggable\", \"\"]],\n    hostVars: 4,\n    hostBindings: function MdbDraggableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdb-draggable\", ctx.movable)(\"mdb-dragging\", ctx.dragging);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      resetPosition: \"resetPosition\",\n      snapSensitivity: \"snapSensitivity\",\n      lockAxis: \"lockAxis\",\n      autoScroll: \"autoScroll\",\n      scrollSpeed: \"scrollSpeed\",\n      scrollSensitivity: \"scrollSensitivity\",\n      snapToGrid: \"snapToGrid\",\n      gridSize: \"gridSize\",\n      boundTo: \"boundTo\",\n      handle: \"handle\"\n    },\n    outputs: {\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\"\n    }\n  });\n  return MdbDraggableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbDraggableModule = /*#__PURE__*/(() => {\n  class MdbDraggableModule {}\n\n  MdbDraggableModule.ɵfac = function MdbDraggableModule_Factory(t) {\n    return new (t || MdbDraggableModule)();\n  };\n\n  MdbDraggableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbDraggableModule\n  });\n  MdbDraggableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return MdbDraggableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbDraggableModule, {\n    declarations: [MdbDraggableDirective],\n    exports: [MdbDraggableDirective]\n  });\n})();\n/*\n * Public API Surface of mdb-draggable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MdbDraggableDirective, MdbDraggableModule }; //# sourceMappingURL=mdb-draggable.js.map","map":null,"metadata":{},"sourceType":"module"}