{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, ElementRef, Renderer2, Inject, HostBinding, Input, Output, ContentChildren, NgModule } from '@angular/core';\nimport { Subject, merge, fromEvent, empty } from 'rxjs';\nimport { filter, concatMap, tap, takeUntil, first, switchMap } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nlet MdbSortableService = /*#__PURE__*/(() => {\n  class MdbSortableService {\n    constructor() {\n      this.dragStart = new Subject();\n      this.dragMove = new Subject();\n      this.dragEnd = new Subject();\n    }\n\n    ngOnDestroy() {\n      this.dragStart.complete();\n      this.dragMove.complete();\n      this.dragEnd.complete();\n    }\n\n  }\n\n  MdbSortableService.ɵfac = function MdbSortableService_Factory(t) {\n    return new (t || MdbSortableService)();\n  };\n\n  MdbSortableService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function MdbSortableService_Factory() {\n      return new MdbSortableService();\n    },\n    token: MdbSortableService,\n    providedIn: \"root\"\n  });\n  return MdbSortableService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction cloneEl(node) {\n  const clone = node.cloneNode(true);\n  clone.removeAttribute('id');\n  return clone;\n}\n\nlet MdbSortableDirective = /*#__PURE__*/(() => {\n  class MdbSortableDirective {\n    constructor(el, renderer, _document, sortableService) {\n      this.el = el;\n      this.renderer = renderer;\n      this._document = _document;\n      this.sortableService = sortableService;\n      this.disabled = false;\n      this.sortThreshold = 5;\n      this.dragStart = new EventEmitter();\n      this.dragEnd = new EventEmitter();\n      this.sortable = true;\n      this._startPos = {\n        x: 0,\n        y: 0\n      };\n      this._elPos = {\n        x: 0,\n        y: 0\n      };\n      this._isDragging = false;\n      this.destroy$ = new Subject();\n    }\n\n    _subscribeToEvents() {\n      const drag = this.start$.pipe(filter(event => event.button !== 2), concatMap(event => {\n        this.onDragStart(event);\n        return this.move$.pipe(tap(moveEvent => {\n          this.onDragMove(moveEvent);\n        }), takeUntil(this.end$));\n      }), takeUntil(this.destroy$));\n      const drop = this.start$.pipe(filter(event => event.button !== 2), concatMap(event => {\n        return this.end$.pipe(first(), tap(() => {\n          this.onDragEnd(event);\n        }));\n      }), takeUntil(this.destroy$));\n      drag.subscribe();\n      drop.subscribe();\n    }\n\n    _createPlaceholder() {\n      const placeholder = cloneEl(this.el.nativeElement);\n      this.renderer.addClass(placeholder, 'mdb-sortable-placeholder');\n      return placeholder;\n    }\n\n    _createHelper() {\n      const helper = cloneEl(this.el.nativeElement);\n      this.renderer.setStyle(helper, 'position', 'fixed');\n      this.renderer.setStyle(helper, 'top', '0');\n      this.renderer.setStyle(helper, 'left', '0');\n      this.renderer.setStyle(helper, 'width', `${this._elRect.width}px`);\n      this.renderer.setStyle(helper, 'height', `${this._elRect.height}px`);\n      this.renderer.setStyle(helper, 'transform', this._getTransform(this._elRect.left, this._elRect.top));\n      this.renderer.addClass(helper, 'mdb-sortable-helper');\n      return helper;\n    }\n\n    _initSortableElements() {\n      const el = this.el.nativeElement;\n\n      const placeholder = this._placeholder = this._createPlaceholder();\n\n      const helper = this._helper = this._createHelper();\n\n      this.renderer.appendChild(this._document.body, el.parentNode.replaceChild(placeholder, el));\n      this.renderer.appendChild(this._document.body, helper);\n      this.renderer.setStyle(el, 'display', 'none');\n    }\n\n    onDragStart(event) {\n      this.activeEl = event.target;\n\n      if (this.disabledDragElements && this.disabledDragElements.find(el => el === event.target)) {\n        return false;\n      } else {\n        event.stopPropagation();\n\n        if (this.disabled) {\n          return;\n        }\n\n        if (event instanceof MouseEvent && event.button === 2) {\n          return;\n        }\n\n        const elRect = this._elRect = this.el.nativeElement.getBoundingClientRect();\n        this._pickUpPos = this._getPointerPos(event);\n        this._startPos.x = elRect.left;\n        this._startPos.y = elRect.top;\n        this.dragStart.emit(this);\n        this.sortableService.dragStart.next(this);\n      }\n    }\n\n    onDragMove(event) {\n      this.activeEl = event.target;\n\n      if (this.disabledDragElements && this.disabledDragElements.find(el => el === event.target)) {\n        return false;\n      } else {\n        if (this.disabled) {\n          return;\n        }\n\n        const pointerPosition = this._getPointerPos(event);\n\n        const diffX = Math.abs(pointerPosition.x - this._pickUpPos.x);\n        const diffY = Math.abs(pointerPosition.y - this._pickUpPos.y);\n        const isOverThreshold = diffX + diffY >= this.sortThreshold; // event.preventDefault();\n\n        if (this._pickUpPos && isOverThreshold) {\n          if (!this._isDragging) {\n            this._isDragging = true;\n\n            this._initSortableElements();\n          }\n\n          this._elPos.x = pointerPosition.x - this._pickUpPos.x + this._startPos.x;\n          this._elPos.y = pointerPosition.y - this._pickUpPos.y + this._startPos.y;\n          this._helper.style.transform = this._getTransform(this._elPos.x, this._elPos.y);\n          this.sortableService.dragMove.next({\n            pointerPosition: pointerPosition,\n            placeholder: this._placeholder,\n            helper: this._helper\n          });\n        }\n      }\n    }\n\n    onDragEnd(event) {\n      if (this.disabledDragElements && this.disabledDragElements.find(el => el === event.target)) {\n        return false;\n      } else {\n        if (this.disabled) {\n          return;\n        }\n\n        if (this._isDragging) {\n          this.renderer.removeStyle(this.el.nativeElement, 'transform');\n\n          if (this._helper) {\n            this.renderer.removeChild(this._document.body, this._helper);\n          }\n\n          if (this._placeholder) {\n            this.renderer.appendChild(this._document.body, this._placeholder.parentNode.replaceChild(this.el.nativeElement, this._placeholder));\n          }\n\n          this.renderer.removeStyle(this.el.nativeElement, 'display');\n\n          if (this._placeholder && this._placeholder.parentNode) {\n            this.renderer.removeChild(this._placeholder.parentNode, this._placeholder);\n          }\n        }\n\n        this.dragEnd.emit();\n        this.sortableService.dragEnd.next(this);\n        this.activeEl = null;\n        this._isDragging = false;\n      }\n    }\n\n    _getDocumentScrollPos() {\n      const documentElement = this._document.documentElement;\n      const body = this._document.body;\n      const top = documentElement.scrollTop || body.scrollTop;\n      const left = documentElement.scrollLeft || body.scrollLeft;\n      return {\n        top,\n        left\n      };\n    }\n\n    _getPointerPos(event) {\n      const point = this._isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n\n      const scrollPos = this._getDocumentScrollPos();\n\n      return {\n        x: point.pageX - scrollPos.left,\n        y: point.pageY - scrollPos.top\n      };\n    }\n\n    _isTouchEvent(event) {\n      return event.type.startsWith('touch');\n    }\n\n    _getTransform(x, y) {\n      return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n    }\n\n    ngOnInit() {\n      this.start$ = merge(fromEvent(this.el.nativeElement, 'mousedown', {\n        passive: false\n      }), fromEvent(this.el.nativeElement, 'touchstart', {\n        passive: false\n      }));\n      this.move$ = merge(fromEvent(this._document, 'mousemove', {\n        passive: false\n      }), fromEvent(this._document, 'touchmove', {\n        passive: false\n      }));\n      this.end$ = merge(fromEvent(this._document, 'mouseup', {\n        passive: false\n      }), fromEvent(this._document, 'touchend', {\n        passive: false\n      }));\n\n      this._subscribeToEvents();\n\n      this._elRect = this.el.nativeElement.getBoundingClientRect();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  MdbSortableDirective.ɵfac = function MdbSortableDirective_Factory(t) {\n    return new (t || MdbSortableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(MdbSortableService));\n  };\n\n  MdbSortableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbSortableDirective,\n    selectors: [[\"\", \"mdbSortable\", \"\"]],\n    hostVars: 4,\n    hostBindings: function MdbSortableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mdb-sortable-disabled\", ctx.disabled)(\"mdb-sortable\", ctx.sortable);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      sortThreshold: \"sortThreshold\",\n      disabledDragElements: \"disabledDragElements\"\n    },\n    outputs: {\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\"\n    }\n  });\n  return MdbSortableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbSortableListDirective = /*#__PURE__*/(() => {\n  class MdbSortableListDirective {\n    constructor(el, _document, sortableService) {\n      this.el = el;\n      this._document = _document;\n      this.sortableService = sortableService;\n      this.autoScroll = false;\n      this.drop = new EventEmitter();\n      this.destroy$ = new Subject();\n      this._scrollSpeed = 10;\n      this._scrollSensitivity = 20;\n    }\n\n    ngOnInit() {}\n\n    ngAfterContentInit() {\n      this._sortables.changes.subscribe(result => {\n        this._sortables = result;\n      });\n\n      const drag = this.sortableService.dragStart.pipe(switchMap(event => {\n        if (this._sortables.toArray().find(el => event === el)) {\n          this._previousList = this._currentList = this;\n          this._currentIndex = this._sortables.toArray().findIndex(el => event === el);\n          this._newIndex = this._currentIndex;\n          return this.sortableService.dragMove.pipe(tap(moveEvent => {\n            this.onSort(moveEvent.pointerPosition, moveEvent.placeholder, moveEvent.helper);\n          }), takeUntil(drop));\n        } else {\n          return empty();\n        }\n      }), takeUntil(this.destroy$));\n      const drop = this.sortableService.dragStart.pipe(switchMap(event => {\n        if (this._sortables.toArray().find(el => event === el)) {\n          return this.sortableService.dragEnd.pipe(first(), tap(() => {\n            this.onDragEnd();\n          }));\n        } else {\n          return empty();\n        }\n      }), takeUntil(this.destroy$));\n      drag.subscribe();\n      drop.subscribe();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    _sortItems(dragged, hovered) {\n      const draggedParent = dragged.parentNode;\n      const hoveredParent = hovered.parentNode;\n\n      if (draggedParent !== hoveredParent) {\n        hoveredParent.insertBefore(dragged, hovered);\n      } else {\n        const temp = this._document.createElement('div');\n\n        draggedParent.insertBefore(temp, dragged);\n        hoveredParent.insertBefore(dragged, hovered);\n        draggedParent.insertBefore(hovered, temp);\n        draggedParent.removeChild(temp);\n      }\n    }\n\n    _updateScrollPos(sortableElement) {\n      const el = this.el.nativeElement;\n      const elRect = sortableElement.getBoundingClientRect();\n      const height = el.clientHeight;\n      const width = el.clientWidth;\n\n      if (elRect.top < this._scrollSensitivity) {\n        el.scrollTop -= this._scrollSpeed;\n      }\n\n      if (elRect.top + elRect.height > height - this._scrollSensitivity) {\n        el.scrollTop += this._scrollSpeed;\n      }\n\n      if (elRect.left < this._scrollSensitivity) {\n        el.scrollLeft -= this._scrollSpeed;\n      }\n\n      if (elRect.left + elRect.width > width - this._scrollSensitivity) {\n        el.scrollLeft += this._scrollSpeed;\n      }\n    }\n\n    _isPointerOverItem(item, x, y) {\n      const {\n        top,\n        bottom,\n        left,\n        right\n      } = item.getBoundingClientRect();\n      return y >= top && y <= bottom && x >= left && x <= right;\n    }\n\n    onSort(pointerPosition, placeholder, helper) {\n      let lists;\n\n      if (this.connectedWith) {\n        lists = this.connectedWith.slice();\n      }\n\n      const currentItem = placeholder;\n      let container = this._sortables;\n      this._previousList = this;\n      this._currentList = this._previousList;\n      let activeList = this.el.nativeElement;\n\n      if (this.autoScroll) {\n        this._updateScrollPos(helper);\n      }\n\n      if (lists && lists.length) {\n        lists.forEach(list => {\n          if (this._isPointerOverItem(list.el.nativeElement, pointerPosition.x, pointerPosition.y)) {\n            container = list._sortables;\n            activeList = list.el.nativeElement;\n            this._currentList = list;\n          } else if (this._isPointerOverItem(this.el.nativeElement, pointerPosition.x, pointerPosition.y)) {\n            container = this._sortables;\n            activeList = this.el.nativeElement;\n            this._currentList = this._previousList;\n          }\n        });\n      }\n\n      const sortables = container;\n      sortables.forEach(item => {\n        if (this._isPointerOverItem(item.el.nativeElement, pointerPosition.x, pointerPosition.y)) {\n          this._sortItems(currentItem, item.el.nativeElement);\n\n          const list = Array.from(activeList.children);\n          this._newIndex = list.findIndex(el => el === currentItem);\n        }\n      });\n    }\n\n    onDragEnd() {\n      this.drop.emit({\n        currentList: this._currentList,\n        previousList: this._previousList,\n        oldIndex: this._currentIndex,\n        newIndex: this._newIndex\n      });\n    }\n\n  }\n\n  MdbSortableListDirective.ɵfac = function MdbSortableListDirective_Factory(t) {\n    return new (t || MdbSortableListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(MdbSortableService));\n  };\n\n  MdbSortableListDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbSortableListDirective,\n    selectors: [[\"\", \"mdbSortableList\", \"\"]],\n    contentQueries: function MdbSortableListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbSortableDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._sortables = _t);\n      }\n    },\n    inputs: {\n      autoScroll: \"autoScroll\",\n      connectedWith: \"connectedWith\",\n      data: \"data\"\n    },\n    outputs: {\n      drop: \"drop\"\n    },\n    exportAs: [\"mdbSortableList\"]\n  });\n  return MdbSortableListDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction moveItemToNewList(currentList, targetList, oldIndex, newIndex) {\n  if (currentList.length > 0) {\n    const item = currentList.splice(oldIndex, 1)[0];\n    targetList.splice(newIndex, 0, item);\n  }\n}\n\nfunction moveItemInList(list, oldIndex, newIndex) {\n  const item = list[oldIndex];\n  list.splice(oldIndex, 1);\n  list.splice(newIndex, 0, item);\n}\n\nlet MdbSortableModule = /*#__PURE__*/(() => {\n  class MdbSortableModule {}\n\n  MdbSortableModule.ɵfac = function MdbSortableModule_Factory(t) {\n    return new (t || MdbSortableModule)();\n  };\n\n  MdbSortableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbSortableModule\n  });\n  MdbSortableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MdbSortableService],\n    imports: [[]]\n  });\n  return MdbSortableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbSortableModule, {\n    declarations: [MdbSortableDirective, MdbSortableListDirective],\n    exports: [MdbSortableDirective, MdbSortableListDirective]\n  });\n})();\n/*\n * Public API Surface of mdb-sortable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MdbSortableDirective, MdbSortableListDirective, MdbSortableModule, MdbSortableService, moveItemInList, moveItemToNewList }; //# sourceMappingURL=mdb-sortable.js.map","map":null,"metadata":{},"sourceType":"module"}