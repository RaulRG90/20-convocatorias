import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Directive, ElementRef, Renderer2, Inject, HostBinding, Input, Output, ContentChildren, NgModule } from '@angular/core';
import { Subject, merge, fromEvent, empty } from 'rxjs';
import { filter, concatMap, tap, takeUntil, first, switchMap } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
class MdbSortableService {
    constructor() {
        this.dragStart = new Subject();
        this.dragMove = new Subject();
        this.dragEnd = new Subject();
    }
    ngOnDestroy() {
        this.dragStart.complete();
        this.dragMove.complete();
        this.dragEnd.complete();
    }
}
MdbSortableService.ɵfac = function MdbSortableService_Factory(t) { return new (t || MdbSortableService)(); };
MdbSortableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdbSortableService_Factory() { return new MdbSortableService(); }, token: MdbSortableService, providedIn: "root" });
MdbSortableService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbSortableService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

function cloneEl(node) {
    const clone = node.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
}
class MdbSortableDirective {
    constructor(el, renderer, _document, sortableService) {
        this.el = el;
        this.renderer = renderer;
        this._document = _document;
        this.sortableService = sortableService;
        this.disabled = false;
        this.sortThreshold = 5;
        this.dragStart = new EventEmitter();
        this.dragEnd = new EventEmitter();
        this.sortable = true;
        this._startPos = { x: 0, y: 0 };
        this._elPos = { x: 0, y: 0 };
        this._isDragging = false;
        this.destroy$ = new Subject();
    }
    _subscribeToEvents() {
        const drag = this.start$.pipe(filter((event) => event.button !== 2), concatMap((event) => {
            this.onDragStart(event);
            return this.move$.pipe(tap((moveEvent) => {
                this.onDragMove(moveEvent);
            }), takeUntil(this.end$));
        }), takeUntil(this.destroy$));
        const drop = this.start$.pipe(filter((event) => event.button !== 2), concatMap((event) => {
            return this.end$.pipe(first(), tap(() => {
                this.onDragEnd(event);
            }));
        }), takeUntil(this.destroy$));
        drag.subscribe();
        drop.subscribe();
    }
    _createPlaceholder() {
        const placeholder = cloneEl(this.el.nativeElement);
        this.renderer.addClass(placeholder, 'mdb-sortable-placeholder');
        return placeholder;
    }
    _createHelper() {
        const helper = cloneEl(this.el.nativeElement);
        this.renderer.setStyle(helper, 'position', 'fixed');
        this.renderer.setStyle(helper, 'top', '0');
        this.renderer.setStyle(helper, 'left', '0');
        this.renderer.setStyle(helper, 'width', `${this._elRect.width}px`);
        this.renderer.setStyle(helper, 'height', `${this._elRect.height}px`);
        this.renderer.setStyle(helper, 'transform', this._getTransform(this._elRect.left, this._elRect.top));
        this.renderer.addClass(helper, 'mdb-sortable-helper');
        return helper;
    }
    _initSortableElements() {
        const el = this.el.nativeElement;
        const placeholder = this._placeholder = this._createPlaceholder();
        const helper = this._helper = this._createHelper();
        this.renderer.appendChild(this._document.body, el.parentNode.replaceChild(placeholder, el));
        this.renderer.appendChild(this._document.body, helper);
        this.renderer.setStyle(el, 'display', 'none');
    }
    onDragStart(event) {
        this.activeEl = event.target;
        if (this.disabledDragElements && this.disabledDragElements.find((el) => el === event.target)) {
            return false;
        }
        else {
            event.stopPropagation();
            if (this.disabled) {
                return;
            }
            if (event instanceof MouseEvent && event.button === 2) {
                return;
            }
            const elRect = this._elRect = this.el.nativeElement.getBoundingClientRect();
            this._pickUpPos = this._getPointerPos(event);
            this._startPos.x = elRect.left;
            this._startPos.y = elRect.top;
            this.dragStart.emit(this);
            this.sortableService.dragStart.next(this);
        }
    }
    onDragMove(event) {
        this.activeEl = event.target;
        if (this.disabledDragElements && this.disabledDragElements.find((el) => el === event.target)) {
            return false;
        }
        else {
            if (this.disabled) {
                return;
            }
            const pointerPosition = this._getPointerPos(event);
            const diffX = Math.abs(pointerPosition.x - this._pickUpPos.x);
            const diffY = Math.abs(pointerPosition.y - this._pickUpPos.y);
            const isOverThreshold = diffX + diffY >= this.sortThreshold;
            // event.preventDefault();
            if (this._pickUpPos && isOverThreshold) {
                if (!this._isDragging) {
                    this._isDragging = true;
                    this._initSortableElements();
                }
                this._elPos.x = pointerPosition.x - this._pickUpPos.x + this._startPos.x;
                this._elPos.y = pointerPosition.y - this._pickUpPos.y + this._startPos.y;
                this._helper.style.transform = this._getTransform(this._elPos.x, this._elPos.y);
                this.sortableService.dragMove.next({
                    pointerPosition: pointerPosition,
                    placeholder: this._placeholder,
                    helper: this._helper
                });
            }
        }
    }
    onDragEnd(event) {
        if (this.disabledDragElements && this.disabledDragElements.find((el) => el === event.target)) {
            return false;
        }
        else {
            if (this.disabled) {
                return;
            }
            if (this._isDragging) {
                this.renderer.removeStyle(this.el.nativeElement, 'transform');
                if (this._helper) {
                    this.renderer.removeChild(this._document.body, this._helper);
                }
                if (this._placeholder) {
                    this.renderer
                        .appendChild(this._document.body, this._placeholder.parentNode.replaceChild(this.el.nativeElement, this._placeholder));
                }
                this.renderer.removeStyle(this.el.nativeElement, 'display');
                if (this._placeholder && this._placeholder.parentNode) {
                    this.renderer.removeChild(this._placeholder.parentNode, this._placeholder);
                }
            }
            this.dragEnd.emit();
            this.sortableService.dragEnd.next(this);
            this.activeEl = null;
            this._isDragging = false;
        }
    }
    _getDocumentScrollPos() {
        const documentElement = this._document.documentElement;
        const body = this._document.body;
        const top = documentElement.scrollTop || body.scrollTop;
        const left = documentElement.scrollLeft || body.scrollLeft;
        return { top, left };
    }
    _getPointerPos(event) {
        const point = this._isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;
        const scrollPos = this._getDocumentScrollPos();
        return {
            x: point.pageX - scrollPos.left,
            y: point.pageY - scrollPos.top
        };
    }
    _isTouchEvent(event) {
        return event.type.startsWith('touch');
    }
    _getTransform(x, y) {
        return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
    }
    ngOnInit() {
        this.start$ = merge(fromEvent(this.el.nativeElement, 'mousedown', { passive: false }), fromEvent(this.el.nativeElement, 'touchstart', { passive: false }));
        this.move$ = merge(fromEvent(this._document, 'mousemove', { passive: false }), fromEvent(this._document, 'touchmove', { passive: false }));
        this.end$ = merge(fromEvent(this._document, 'mouseup', { passive: false }), fromEvent(this._document, 'touchend', { passive: false }));
        this._subscribeToEvents();
        this._elRect = this.el.nativeElement.getBoundingClientRect();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
MdbSortableDirective.ɵfac = function MdbSortableDirective_Factory(t) { return new (t || MdbSortableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(MdbSortableService)); };
MdbSortableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbSortableDirective, selectors: [["", "mdbSortable", ""]], hostVars: 4, hostBindings: function MdbSortableDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mdb-sortable-disabled", ctx.disabled)("mdb-sortable", ctx.sortable);
    } }, inputs: { disabled: "disabled", sortThreshold: "sortThreshold", disabledDragElements: "disabledDragElements" }, outputs: { dragStart: "dragStart", dragEnd: "dragEnd" } });
MdbSortableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: MdbSortableService }
];
MdbSortableDirective.propDecorators = {
    disabled: [{ type: HostBinding, args: ['class.mdb-sortable-disabled',] }, { type: Input }],
    disabledDragElements: [{ type: Input }],
    sortThreshold: [{ type: Input }],
    dragStart: [{ type: Output }],
    dragEnd: [{ type: Output }],
    sortable: [{ type: HostBinding, args: ['class.mdb-sortable',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbSortableDirective, [{
        type: Directive,
        args: [{
                selector: '[mdbSortable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: MdbSortableService }]; }, { disabled: [{
            type: HostBinding,
            args: ['class.mdb-sortable-disabled']
        }, {
            type: Input
        }], sortThreshold: [{
            type: Input
        }], dragStart: [{
            type: Output
        }], dragEnd: [{
            type: Output
        }], sortable: [{
            type: HostBinding,
            args: ['class.mdb-sortable']
        }], disabledDragElements: [{
            type: Input
        }] }); })();

class MdbSortableListDirective {
    constructor(el, _document, sortableService) {
        this.el = el;
        this._document = _document;
        this.sortableService = sortableService;
        this.autoScroll = false;
        this.drop = new EventEmitter();
        this.destroy$ = new Subject();
        this._scrollSpeed = 10;
        this._scrollSensitivity = 20;
    }
    ngOnInit() { }
    ngAfterContentInit() {
        this._sortables.changes.subscribe(result => {
            this._sortables = result;
        });
        const drag = this.sortableService.dragStart.pipe(switchMap((event) => {
            if (this._sortables.toArray().find(el => event === el)) {
                this._previousList = this._currentList = this;
                this._currentIndex = this._sortables
                    .toArray()
                    .findIndex((el) => event === el);
                this._newIndex = this._currentIndex;
                return this.sortableService.dragMove.pipe(tap((moveEvent) => {
                    this.onSort(moveEvent.pointerPosition, moveEvent.placeholder, moveEvent.helper);
                }), takeUntil(drop));
            }
            else {
                return empty();
            }
        }), takeUntil(this.destroy$));
        const drop = this.sortableService.dragStart.pipe(switchMap((event) => {
            if (this._sortables.toArray().find(el => event === el)) {
                return this.sortableService.dragEnd.pipe(first(), tap(() => {
                    this.onDragEnd();
                }));
            }
            else {
                return empty();
            }
        }), takeUntil(this.destroy$));
        drag.subscribe();
        drop.subscribe();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    _sortItems(dragged, hovered) {
        const draggedParent = dragged.parentNode;
        const hoveredParent = hovered.parentNode;
        if (draggedParent !== hoveredParent) {
            hoveredParent.insertBefore(dragged, hovered);
        }
        else {
            const temp = this._document.createElement('div');
            draggedParent.insertBefore(temp, dragged);
            hoveredParent.insertBefore(dragged, hovered);
            draggedParent.insertBefore(hovered, temp);
            draggedParent.removeChild(temp);
        }
    }
    _updateScrollPos(sortableElement) {
        const el = this.el.nativeElement;
        const elRect = sortableElement.getBoundingClientRect();
        const height = el.clientHeight;
        const width = el.clientWidth;
        if (elRect.top < this._scrollSensitivity) {
            el.scrollTop -= this._scrollSpeed;
        }
        if (elRect.top + elRect.height > height - this._scrollSensitivity) {
            el.scrollTop += this._scrollSpeed;
        }
        if (elRect.left < this._scrollSensitivity) {
            el.scrollLeft -= this._scrollSpeed;
        }
        if (elRect.left + elRect.width > width - this._scrollSensitivity) {
            el.scrollLeft += this._scrollSpeed;
        }
    }
    _isPointerOverItem(item, x, y) {
        const { top, bottom, left, right } = item.getBoundingClientRect();
        return y >= top && y <= bottom && x >= left && x <= right;
    }
    onSort(pointerPosition, placeholder, helper) {
        let lists;
        if (this.connectedWith) {
            lists = this.connectedWith.slice();
        }
        const currentItem = placeholder;
        let container = this._sortables;
        this._previousList = this;
        this._currentList = this._previousList;
        let activeList = this.el.nativeElement;
        if (this.autoScroll) {
            this._updateScrollPos(helper);
        }
        if (lists && lists.length) {
            lists.forEach(list => {
                if (this._isPointerOverItem(list.el.nativeElement, pointerPosition.x, pointerPosition.y)) {
                    container = list._sortables;
                    activeList = list.el.nativeElement;
                    this._currentList = list;
                }
                else if (this._isPointerOverItem(this.el.nativeElement, pointerPosition.x, pointerPosition.y)) {
                    container = this._sortables;
                    activeList = this.el.nativeElement;
                    this._currentList = this._previousList;
                }
            });
        }
        const sortables = container;
        sortables.forEach(item => {
            if (this._isPointerOverItem(item.el.nativeElement, pointerPosition.x, pointerPosition.y)) {
                this._sortItems(currentItem, item.el.nativeElement);
                const list = Array.from(activeList.children);
                this._newIndex = list.findIndex((el) => el === currentItem);
            }
        });
    }
    onDragEnd() {
        this.drop.emit({
            currentList: this._currentList,
            previousList: this._previousList,
            oldIndex: this._currentIndex,
            newIndex: this._newIndex
        });
    }
}
MdbSortableListDirective.ɵfac = function MdbSortableListDirective_Factory(t) { return new (t || MdbSortableListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(MdbSortableService)); };
MdbSortableListDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbSortableListDirective, selectors: [["", "mdbSortableList", ""]], contentQueries: function MdbSortableListDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbSortableDirective, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._sortables = _t);
    } }, inputs: { autoScroll: "autoScroll", connectedWith: "connectedWith", data: "data" }, outputs: { drop: "drop" }, exportAs: ["mdbSortableList"] });
MdbSortableListDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: MdbSortableService }
];
MdbSortableListDirective.propDecorators = {
    _sortables: [{ type: ContentChildren, args: [MdbSortableDirective,] }],
    autoScroll: [{ type: Input }],
    connectedWith: [{ type: Input }],
    data: [{ type: Input }],
    drop: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbSortableListDirective, [{
        type: Directive,
        args: [{
                selector: '[mdbSortableList]',
                exportAs: 'mdbSortableList'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: MdbSortableService }]; }, { autoScroll: [{
            type: Input
        }], drop: [{
            type: Output
        }], _sortables: [{
            type: ContentChildren,
            args: [MdbSortableDirective]
        }], connectedWith: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();

function moveItemToNewList(currentList, targetList, oldIndex, newIndex) {
    if (currentList.length > 0) {
        const item = currentList.splice(oldIndex, 1)[0];
        targetList.splice(newIndex, 0, item);
    }
}
function moveItemInList(list, oldIndex, newIndex) {
    const item = list[oldIndex];
    list.splice(oldIndex, 1);
    list.splice(newIndex, 0, item);
}

class MdbSortableModule {
}
MdbSortableModule.ɵfac = function MdbSortableModule_Factory(t) { return new (t || MdbSortableModule)(); };
MdbSortableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbSortableModule });
MdbSortableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MdbSortableService], imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbSortableModule, [{
        type: NgModule,
        args: [{
                declarations: [MdbSortableDirective, MdbSortableListDirective],
                imports: [],
                exports: [MdbSortableDirective, MdbSortableListDirective],
                providers: [MdbSortableService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbSortableModule, { declarations: [MdbSortableDirective, MdbSortableListDirective], exports: [MdbSortableDirective, MdbSortableListDirective] }); })();

/*
 * Public API Surface of mdb-sortable
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbSortableDirective, MdbSortableListDirective, MdbSortableModule, MdbSortableService, moveItemInList, moveItemToNewList };

//# sourceMappingURL=mdb-sortable.js.map