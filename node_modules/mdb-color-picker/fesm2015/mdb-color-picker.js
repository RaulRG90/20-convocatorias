import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Component, Renderer2, Inject, PLATFORM_ID, Input, Output, ViewChild, HostListener, ChangeDetectorRef, ElementRef, Directive, HostBinding, forwardRef, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { takeUntil } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

class MdbColorPickerService {
    constructor() {
        this._segmentedColorChange = new Subject();
        this._alpha = '0.5';
        this._alphaChange = new Subject();
        this._coordsChange = new Subject();
        this._rgbaSegments = ['255', '255', '255', '0.5'];
        this._color = { rgbaColor: '', hexColor: '' };
        this._colorChange = new Subject();
        this._colorPalette = [];
        this._colorPaletteChange = new Subject();
    }
    setColorPalette(colorArray) {
        this._colorPalette = colorArray;
        this._colorPaletteChange.next(this.getColorPalette());
    }
    addColorToPalette(color) {
        this._colorPalette.push(color);
        this._colorPaletteChange.next(this.getColorPalette());
    }
    getColorPalette() {
        return this._colorPalette;
    }
    removeColorFromPalette(index) {
        this._colorPalette.splice(index, 1);
    }
    colorPaletteWasChanged() {
        return this._colorPaletteChange;
    }
    setColor(rgbaColor, hexColor) {
        this._color.rgbaColor = rgbaColor;
        this._color.hexColor = hexColor;
        this._colorChange.next(this.getColor());
    }
    getColor() {
        return this._color;
    }
    colorWasChanged() {
        return this._colorChange;
    }
    setSegmentedColor(value) {
        this._segmentedColor = value;
        this._segmentedColorChange.next(this.getSegmentedColor());
        const rgbaColor = this.convertToRGBA();
        const hexColor = this.rgbaToHex(this.getRgbaColor());
        this.setColor(rgbaColor, hexColor);
    }
    getSegmentedColor() {
        return this._segmentedColor;
    }
    colorSegmentedWasChanged() {
        return this._segmentedColorChange;
    }
    setAlpha(value) {
        this._alpha = value;
        this._alphaChange.next(this.getAlpha());
        const rgbaColor = this.convertToRGBA();
        const hexColor = this.rgbaToHex(this.getRgbaColor());
        this.setColor(rgbaColor, hexColor);
    }
    getAlpha() {
        return this._alpha;
    }
    alphaWasChanged() {
        return this._alphaChange;
    }
    setCoords(value) {
        this._coords = value;
        this._coordsChange.next(this.getCoords());
    }
    getCoords() {
        return this._coords;
    }
    coordsWasChanged() {
        return this._coordsChange;
    }
    convertToRGBA() {
        this._rgbaColor = this.getSegmentedColor().split(',');
        const alphaChannel = this.getAlpha();
        this._rgbaSegments[0] = this._rgbaColor[0];
        this._rgbaSegments[1] = this._rgbaColor[1];
        this._rgbaSegments[2] = this._rgbaColor[2];
        this._rgbaSegments[3] = alphaChannel;
        return 'rgba(' + this._rgbaSegments.toString() + ')';
    }
    getRgbaColor() {
        return this.convertToRGBA();
    }
    getHexColor() {
        return this.rgbaToHex(this.getSegmentedColor() + ',' + this.getAlpha());
    }
    rgbaToHex(value) {
        value = value.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return (value && value.length === 4) ? '#' +
            ('0' + parseInt(value[1], 10).toString(16)).slice(-2) +
            ('0' + parseInt(value[2], 10).toString(16)).slice(-2) +
            ('0' + parseInt(value[3], 10).toString(16)).slice(-2) : '';
    }
    hexToRgba(value, alpha) {
        const r = parseInt(value.slice(1, 3), 16);
        const g = parseInt(value.slice(3, 5), 16);
        const b = parseInt(value.slice(5, 7), 16);
        if (alpha) {
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        else {
            return `rgb(${r}, ${g}, ${b})`;
        }
    }
}
MdbColorPickerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdbColorPickerService_Factory() { return new MdbColorPickerService(); }, token: MdbColorPickerService, providedIn: "root" });
MdbColorPickerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
MdbColorPickerService.ctorParameters = () => [];

class MdbColorPaletteComponent {
    constructor(renderer, colorService, platformId) {
        this.renderer = renderer;
        this.colorService = colorService;
        this.platformId = platformId;
        this.color = new EventEmitter(true);
        this.mousedown = false;
        this.isBrowser = false;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.colorService.coordsWasChanged().subscribe((data) => {
            this.getColorAtPosition(data.x, data.y);
            this.selectedPosition = { x: data.x, y: data.y };
            this.draw();
        });
        this.colorService.colorWasChanged().subscribe(() => {
            this.draw();
        });
    }
    onmouseup() {
        this.mousedown = false;
    }
    draw() {
        if (this.isBrowser) {
            if (!this.ctx) {
                this.ctx = this.canvas.nativeElement.getContext('2d');
            }
            setTimeout(() => {
                const canvasParentWidth = this.canvas.nativeElement.parentElement
                    .parentElement.clientWidth;
                this.renderer.setAttribute(this.canvas.nativeElement, 'width', canvasParentWidth + 'px');
                const width = this.canvas.nativeElement.clientWidth;
                const height = this.canvas.nativeElement.clientHeight;
                this.ctx.fillStyle = this.hue || 'rgba(255, 255, 255, 1)';
                this.ctx.fillRect(0, 0, width, height);
                const whiteGrad = this.ctx.createLinearGradient(0, 0, width, 0);
                whiteGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                whiteGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                this.ctx.fillStyle = whiteGrad;
                this.ctx.fillRect(0, 0, width, height);
                const blackGrad = this.ctx.createLinearGradient(0, 0, 0, height);
                blackGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                blackGrad.addColorStop(1, 'rgba(0, 0, 0, 1)');
                this.ctx.fillStyle = blackGrad;
                this.ctx.fillRect(0, 0, width, height);
                if (this.selectedPosition) {
                    this.ctx.strokeStyle = 'white';
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 5, 0, 2 * Math.PI);
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }, 0);
        }
    }
    ngOnChanges(changes) {
        if (changes['hue']) {
            this.draw();
            const pos = this.selectedPosition;
            if (pos) {
                this.getColorAtPosition(pos.x, pos.y);
            }
        }
    }
    onMouseDown(event) {
        this.mousedown = true;
        if (event.type === 'touchstart') {
            const rect = event.target.getBoundingClientRect();
            this.selectedPosition = {
                x: event.targetTouches[0].pageX - rect.left,
                y: event.targetTouches[0].pageY - rect.top
            };
        }
        else if (event.type === 'mousedown') {
            this.selectedPosition = { x: event.offsetX, y: event.offsetY };
        }
        this.draw();
        this.getColorAtPosition(this.selectedPosition.x, this.selectedPosition.y);
    }
    onMouseMove(event) {
        if (this.mousedown) {
            if (event.type === 'touchmove') {
                event.preventDefault();
                const rect = event.target.getBoundingClientRect();
                this.selectedPosition = {
                    x: event.targetTouches[0].pageX - rect.left,
                    y: event.targetTouches[0].pageY - rect.top
                };
            }
            else if (event.type === 'mousemove') {
                this.selectedPosition = { x: event.offsetX, y: event.offsetY };
            }
            this.draw();
            this.getColorAtPosition(this.selectedPosition.x, this.selectedPosition.y);
        }
    }
    getColorAtPosition(x, y) {
        if (this.isBrowser) {
            const imageData = this.ctx.getImageData(x, y, 1, 1).data;
            this.colorService.setSegmentedColor(`${imageData[0]},${imageData[1]},${imageData[2]}`);
            return ('rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)');
        }
    }
    pickColorAtStart(x, y) {
        if (this.isBrowser) {
            this.selectedPosition = { x: x, y: y };
            this.ctx.strokeStyle = 'white';
            this.ctx.fillStyle = 'white';
            this.ctx.beginPath();
            this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 10, 0, 2 * Math.PI);
            this.ctx.lineWidth = 5;
            this.ctx.stroke();
            this.getColorAtPosition(x, y);
            this.colorService.setCoords({ x: x, y: y });
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.pickColorAtStart(195, 75);
            this.draw();
        }, 0);
    }
}
MdbColorPaletteComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdb-color-palette',
                template: "<canvas #canvas class=\"color-palette\" (mousedown)=\"onMouseDown($event)\" (touchstart)=\"onMouseDown($event)\" (touchmove)=\"onMouseMove($event)\" (mousemove)=\"onMouseMove($event)\">\n</canvas>\n",
                styles: [".color-palette:hover{cursor:pointer}\n"]
            },] }
];
MdbColorPaletteComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: MdbColorPickerService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
MdbColorPaletteComponent.propDecorators = {
    hue: [{ type: Input }],
    color: [{ type: Output }],
    canvas: [{ type: ViewChild, args: ['canvas', { static: true },] }],
    onmouseup: [{ type: HostListener, args: ['window:mouseup',] }]
};

class MdbColorPickerComponent {
    constructor(colorService, cdRef, el, renderer) {
        this.colorService = colorService;
        this.cdRef = cdRef;
        this.el = el;
        this.renderer = renderer;
        this.colorPalette = [];
        this.defaultRangeSlider = true;
        this.config = {
            showPalette: true,
            showOpacitySlider: true,
            showRgbaHexColorText: true
        };
        this.alphaChannel = '0.5';
        this.opacityValue = '';
        this.colorSegments = ['255', '255', '255', '1'];
        this.switchValue = false;
        this.isBrowser = false;
        this.showPicker = false;
        this.componentDestroyed = new Subject();
        this.colorService
            .colorSegmentedWasChanged()
            .pipe(takeUntil(this.componentDestroyed))
            .subscribe((data) => {
            this.colorString =
                'rgba(' + data.split(',') + ', ' + this.alphaChannel + ')';
            this.color = this.colorService.getSegmentedColor();
            this.color = this.color.split(',');
            this.change();
            this.cdRef.detectChanges();
        });
        this.colorService.alphaWasChanged().subscribe(() => {
            this.alphaChannel = this.colorService.getAlpha();
        });
        this.colorService.coordsWasChanged().subscribe(() => {
            this.colorService.colorWasChanged().subscribe((color) => {
                if (this.switchValue === false) {
                    this.colorString = color.rgbaColor;
                }
                else {
                    this.colorString = color.hexColor;
                }
            });
        });
        this.colorService.colorPaletteWasChanged().subscribe((data) => {
            this.colorPalette = data;
        });
        // Resolves problem with hidden canvas of color picker and color slider
        // when color picker component was placed inside of static modal
        this.observer = new MutationObserver(mutations => {
            mutations.forEach((mutation) => {
                const stylesAttribute = mutation.target.getAttribute('style');
                if (stylesAttribute) {
                    this.showPicker = stylesAttribute.includes('visibility: visible');
                    this.cdRef.detectChanges();
                }
            });
        });
        this.observer.observe(this.el.nativeElement, {
            attributes: true,
            childList: true,
            characterData: true
        });
    }
    setOptions() {
        if (this.options !== undefined) {
            Object.keys(this.options).forEach((k) => {
                this.config[k] = this.options[k];
            });
        }
    }
    onAlphaInput(event) {
        this.colorService.setAlpha(event.target.value);
        this.colorSegments[0] = this.color[0];
        this.colorSegments[1] = this.color[1];
        this.colorSegments[2] = this.color[2];
        this.colorSegments[3] = this.alphaChannel;
        this.colorString = 'rgba(' + this.colorSegments.toString() + ')';
        this.change();
    }
    copyToClipboard(type) {
        const el = this.renderer.createElement('textarea');
        if (type === 'color') {
            el.value = this.colorString;
        }
        else if (type === 'palette') {
            this.colorService.getColorPalette().forEach((color) => {
                el.value += '{';
                el.value += 'rgbaColor: ' + `'${color.rgbaColor}'` + ', ';
                el.value += 'hexColor: ' + `'${color.hexColor}'`;
                el.value += '}, ';
            });
        }
        this.renderer.setAttribute(el, 'readonly', '');
        this.renderer.setStyle(el, 'position', 'absolute');
        this.renderer.setStyle(el, 'left', '-9999px');
        this.renderer.appendChild(document.body, el);
        el.select();
        document.execCommand('copy');
        this.renderer.removeChild(document.body, el);
    }
    clearColor() {
        if (this.colorService.getCoords()) {
            this.colorService.setCoords({
                x: this.colorService.getCoords().x,
                y: this.colorService.getCoords().y
            });
        }
        else {
            this.colorService.setCoords({ x: 122, y: 137 });
        }
        this.change();
        if (this.colorService.getAlpha() !== '0.5') {
            this.colorService.setAlpha(this.colorService.getAlpha());
        }
        else {
            this.colorService.setAlpha('0.5');
        }
        this.colorService.setColorPalette([]);
    }
    addColorToPalette() {
        this.colorService.addColorToPalette({
            rgbaColor: this.colorService.getColor().rgbaColor,
            hexColor: this.colorService.getColor().hexColor
        });
        this.colorPalette = this.colorService.getColorPalette();
    }
    setColorPaletteCircleColor(index) {
        if (!this.switchValue) {
            return this.colorPalette[index].rgbaColor;
        }
        else if (this.switchValue) {
            return this.colorPalette[index].hexColor;
        }
    }
    changeColorSystemTo(colorSystem) {
        if (colorSystem === 'rgba') {
            this.colorString = this.colorService.getColor().rgbaColor;
            return 'rgba';
        }
        else {
            this.colorString = this.colorService.getColor().hexColor;
            return 'hex';
        }
    }
    change() {
        if (!this.switchValue) {
            this.changeColorSystemTo('rgba');
        }
        else {
            this.changeColorSystemTo('hex');
        }
    }
    changeColorType() {
        this.switchValue = !this.switchValue;
        this.change();
    }
    ngAfterViewInit() {
        this.changeColorSystemTo('rgba');
        if (this.colorPalette) {
            this.colorService.setColorPalette(this.colorPalette);
        }
        this.setOptions();
        this.cdRef.detectChanges();
    }
    ngOnDestroy() {
        this.observer.disconnect();
        this.componentDestroyed.next();
        this.componentDestroyed.complete();
    }
}
MdbColorPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdb-color-picker',
                template: "<div class=\"card d-flex\" *ngIf=\"showPicker\">\n\n  <div class=\"card-body color-picker-card flex-column flex-center\">\n    <div class=\"row w-100\">\n      <div class=\"col-md-12 w-100 d-flex flex-column flex-center\">\n        <mdb-color-palette [hue]=\"hue\" (color)=\"color = $event\"></mdb-color-palette>\n      </div>\n    </div>\n\n    <div class=\"row w-100\">\n      <div class=\"col-md-12 py-2 d-flex\">\n        <mdb-color-slider (color)=\"hue = $event\"></mdb-color-slider>\n      </div>\n    </div>\n\n    <div class=\"row w-100\" *ngIf=\"config.showOpacitySlider\">\n      <div class=\"col-md-12 py-2 d-flex p-0\">\n        <mdb-color-picker-alpha-slider\n          class=\"w-100\"\n          id=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.01\"\n          [value]=\"alphaChannel\"\n          (input)=\"onAlphaInput($event)\"\n          [(ngModel)]=\"opacityValue\"\n          [default]=\"defaultRangeSlider\">\n        </mdb-color-picker-alpha-slider>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 d-flex flex-center flex-column\">\n        <div class=\"flex-row py-2 flex-center\" *ngIf=\"config.showRgbaHexColorText\">\n          <div class=\"color-div z-depth-1 mx-2\" [ngStyle]=\"{'background-color': colorString || 'white'}\"></div>\n          <p class=\"\">{{colorString}}</p>\n        </div>\n        <ng-content select=\".color-picker-switch\"></ng-content>\n      </div>\n\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 d-flex flex-center text-center\">\n        <ng-content select=\".color-picker-buttons\"></ng-content>\n      </div>\n    </div>\n\n    <div class=\"row\" *ngIf=\"config.showPalette\">\n      <div class=\"col-md-12 d-flex flex-center text-center flex-wrap\">\n        <div class=\"color-palette-circle m-1 d-flex flex-center\"\n             [ngStyle]=\"{'background-color': setColorPaletteCircleColor(i)}\"\n             *ngFor=\"let color of colorPalette; let i = index\">\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n",
                exportAs: 'mdb-color-picker',
                styles: [".input-wrapper{margin-top:16px;display:flex;border-radius:1px;border:1px solid gainsboro;padding:8px;height:32px;justify-content:center}.color-div{width:1rem;height:1rem;border-radius:50%}.color-slider-text{margin-top:-5px}.switch.primary-switch label input[type=checkbox]:checked+.lever{background-color:#689df6}.switch label input[type=checkbox]:checked+.lever:after{background-color:#4285f4}.color-palette-circle{width:2rem;height:2rem;border-radius:50%}\n"]
            },] }
];
MdbColorPickerComponent.ctorParameters = () => [
    { type: MdbColorPickerService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 }
];
MdbColorPickerComponent.propDecorators = {
    colorPalette: [{ type: Input }],
    options: [{ type: Input }],
    defaultRangeSlider: [{ type: Input }]
};

class MdbColorDraggableDirective {
    constructor(el) {
        this.el = el;
        this.elementPosition = { x: 0 };
        this.movable = true;
    }
    onStartMove(event) {
        this.isElementMoving = true;
        this.startMoving(event);
    }
    onMove(event) {
        if (!this.isElementMoving) {
            return;
        }
        this.movingOver(event);
    }
    onEndMove() {
        if (!this.isElementMoving) {
            return;
        }
        this.isElementMoving = false;
    }
    startMoving(event) {
        if (event.type === 'mousedown') {
            this.startingPosition = {
                x: event.clientX - this.elementPosition.x
            };
        }
        else {
            this.startingPosition = {
                x: event.changedTouches[0].clientX - this.elementPosition.x
            };
        }
    }
    movingOver(event) {
        if (event.type === 'mousemove') {
            this.elementPosition.x = event.clientX - this.startingPosition.x;
        }
        else {
            this.elementPosition.x =
                event.changedTouches[0].clientX - this.startingPosition.x;
        }
        this.updatePosition();
    }
    moveTo(value) {
        this.elementPosition.x = value;
        this.updatePosition();
    }
    updatePosition() {
        if (this.elementPosition.x >= 1 &&
            this.elementPosition.x <= this.el.nativeElement.parentElement.offsetWidth) {
            requestAnimationFrame(() => {
                this.el.nativeElement.style.transform = `
                translateX(${this.elementPosition.x}px)
              `;
            });
        }
    }
}
MdbColorDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdbColorDraggable]'
            },] }
];
MdbColorDraggableDirective.ctorParameters = () => [
    { type: ElementRef }
];
MdbColorDraggableDirective.propDecorators = {
    movable: [{ type: HostBinding, args: ['class.mdb-movable',] }],
    onStartMove: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }],
    onMove: [{ type: HostListener, args: ['document:mousemove', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }],
    onEndMove: [{ type: HostListener, args: ['document:mouseup',] }, { type: HostListener, args: ['touchend',] }]
};

class MdbColorSliderComponent {
    constructor(renderer, el, platformId) {
        this.renderer = renderer;
        this.el = el;
        this.platformId = platformId;
        this.color = new EventEmitter();
        this.mousedown = false;
        this.previousImageData = null;
        this.isBrowser = false;
        this.isBrowser = isPlatformBrowser(this.platformId);
    }
    handleMouseDown() {
        if (this.isBrowser) {
            this.mousedown = true;
            this.renderer.addClass(this.handle.nativeElement, 'pop');
            this.renderer.addClass(this.slider.nativeElement, 'grad');
            this.renderer.setStyle(this.canvas.nativeElement, 'margin-left', '-13px');
        }
    }
    moveColorCircleToPosition(event) {
        const rect = event.target.getBoundingClientRect();
        let pos = null;
        if (event.type === 'touchmove') {
            event.preventDefault();
            this.drag.moveTo(event.targetTouches[0].pageX - rect.left);
            this.drag.elementPosition.x = event.targetTouches[0].pageX - rect.left;
            pos = {
                x: event.targetTouches[0].pageX -
                    this.slider.nativeElement.getBoundingClientRect().left,
                y: event.targetTouches[0].pageY -
                    this.slider.nativeElement.getBoundingClientRect().top
            };
        }
        else if (event.type === 'click') {
            this.drag.moveTo(event.layerX);
            this.drag.elementPosition.x = event.layerX;
            pos = {
                x: event.x - this.slider.nativeElement.getBoundingClientRect().x,
                y: event.y - this.slider.nativeElement.getBoundingClientRect().y
            };
        }
        if (pos !== null) {
            this.draw();
            this.emitColor(pos.x, pos.y);
            this.renderer.setStyle(this.handle.nativeElement, 'background-color', this.getColorAtPosition(pos.x, pos.y));
        }
    }
    handleMouseUp() {
        this.mousedown = false;
        this.renderer.removeClass(this.handle.nativeElement, 'pop');
        this.renderer.removeClass(this.slider.nativeElement, 'grad');
    }
    handleMouseMove(event) {
        if (this.mousedown) {
            let left = 0;
            let pos = null;
            if (event.type === 'touchmove') {
                event.preventDefault();
                left =
                    event.targetTouches[0].pageX -
                        this.slider.nativeElement.getBoundingClientRect().left +
                        5;
                const rect = event.target.getBoundingClientRect();
                pos = {
                    x: event.targetTouches[0].pageX - rect.left,
                    y: event.targetTouches[0].pageY - rect.top
                };
            }
            else if (event.type === 'mousemove') {
                left =
                    event.clientX -
                        this.slider.nativeElement.getBoundingClientRect().left +
                        5;
                pos = {
                    x: event.x - this.slider.nativeElement.getBoundingClientRect().x,
                    y: event.y - this.slider.nativeElement.getBoundingClientRect().y
                };
            }
            if (left <= this.sliderParent.clientWidth && pos !== null) {
                this.draw();
                this.emitColor(pos.x, pos.y);
                this.renderer.setStyle(this.handle.nativeElement, 'background-color', this.getColorAtPosition(pos.x, pos.y));
            }
        }
    }
    draw() {
        if (this.isBrowser) {
            if (!this.ctx) {
                this.ctx = this.canvas.nativeElement.getContext('2d');
            }
            setTimeout(() => {
                const width = this.sliderParent.clientWidth;
                const height = 12;
                this.renderer.setAttribute(this.canvas.nativeElement, 'width', width + 'px');
                let grd;
                grd = this.ctx.createLinearGradient(0.0, 150.0, width, 12);
                grd.addColorStop(0.0, 'rgba(255, 0, 0, 1.000)');
                grd.addColorStop(0.2, 'rgba(255, 0, 255, 1.000)');
                grd.addColorStop(0.35, 'rgba(0, 0, 255, 1.000)');
                grd.addColorStop(0.52, 'rgba(0, 255, 255, 1.000)');
                grd.addColorStop(0.71, 'rgba(0, 255, 0, 1.000)');
                grd.addColorStop(0.88, 'rgba(255, 255, 0, 1.000)');
                grd.addColorStop(1.0, 'rgba(255, 0, 148, 1.000)');
                this.ctx.fillStyle = grd;
                this.ctx.fillRect(0, 0, width, height);
            }, 0);
        }
    }
    ngAfterViewInit() {
        if (this.isBrowser) {
            this.sliderParent = this.slider.nativeElement.parentElement.parentElement.parentElement;
            this.renderer.setStyle(this.slider.nativeElement, 'width', this.sliderParent.clientWidth + 'px');
            this.draw();
            this.renderer.setStyle(this.canvas.nativeElement, 'margin-left', '-13px');
            this.setCanvasParentsWidth();
        }
    }
    setCanvasParentsWidth() {
        setTimeout(() => {
            this.renderer.setStyle(this.el.nativeElement, 'width', this.sliderParent.clientWidth + 'px');
        }, 0);
    }
    emitColor(x, y) {
        const rgbaColor = this.getColorAtPosition(x, y);
        this.color.emit(rgbaColor);
    }
    getColorAtPosition(x, y) {
        if (this.isBrowser) {
            const imageData = this.ctx.getImageData(x, y, 1, 1).data;
            if (imageData[0] + imageData[1] + imageData[2] > 0 ||
                this.previousImageData == null) {
                this.previousImageData = imageData;
            }
            else {
                return `rgba(${this.previousImageData[0]},${this.previousImageData[1]}, ${this.previousImageData[2]}, 1)`;
            }
            return ('rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)');
        }
    }
}
MdbColorSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdb-color-slider',
                template: "<div class=\"row\">\n  <div class=\"col-md-12 slider\" #slider>\n    <canvas #canvas class=\"color-slider\" height=\"12\"\n            (touchmove)=\"moveColorCircleToPosition($event)\"\n            (click)=\"moveColorCircleToPosition($event)\"\n            (mousedown)=\"handleMouseDown()\"\n            (touchstart)=\"handleMouseDown()\"\n            (mouseup)=\"handleMouseUp()\"\n            (touchend)=\"handleMouseUp()\">\n    </canvas>\n    <div class=\"handle\" #handle\n         (mousemove)=\"handleMouseMove($event)\"\n         (mousedown)=\"handleMouseDown()\"\n         (mouseup)=\"handleMouseUp()\"\n         (touchmove)=\"handleMouseMove($event)\"\n         (touchstart)=\"handleMouseDown()\"\n         (touchend)=\"handleMouseUp()\"\n         mdbColorDraggable></div>\n  </div>\n</div>\n",
                styles: [".color-slider:hover{cursor:pointer}.slider{position:relative;width:100%;height:12px;border-radius:2px}.color-slider{margin-bottom:10px}.handle{position:absolute;top:-8px;left:0;width:24px;height:24px;border-radius:12px;background:red;transition:box-shadow .2s}.handle:before{content:\"\";position:absolute;top:8px;left:50%;margin-left:-2px;background:inherit;width:4px;height:4px;border-radius:20px;transition:top .2s,left .2s,margin-left .2s,height .2s,width .2s}.handle.pop:before{top:-50px;left:50%;margin-left:-20px;background:inherit;width:40px;height:40px;border-radius:20px;box-shadow:0 4px 10px #0000004d}\n"]
            },] }
];
MdbColorSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
MdbColorSliderComponent.propDecorators = {
    handle: [{ type: ViewChild, args: ['handle', { static: true },] }],
    slider: [{ type: ViewChild, args: ['slider', { static: true },] }],
    canvas: [{ type: ViewChild, args: ['canvas', { static: true },] }],
    drag: [{ type: ViewChild, args: [MdbColorDraggableDirective, { static: true },] }],
    color: [{ type: Output }]
};

const RANGE_VALUE_ACCESOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdbColorPickerAlphaSliderComponent),
    multi: true
};
class MdbColorPickerAlphaSliderComponent {
    constructor(renderer, cdRef) {
        this.renderer = renderer;
        this.cdRef = cdRef;
        this.min = 0;
        this.max = 100;
        this.rangeValueChange = new EventEmitter();
        this.range = 0;
        this.cloudRange = 0;
        this.visibility = false;
        // Control Value Accessor Methods
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    onchange(event) {
        this.onChange(event.target.value);
    }
    oninput(event) {
        const value = +event.target.value;
        this.rangeValueChange.emit({ value: value });
        if (this.checkIfSafari()) {
            this.focusRangeInput();
        }
    }
    onclick() {
        this.focusRangeInput();
    }
    onmouseleave() {
        if (this.checkIfSafari()) {
            this.blurRangeInput();
        }
    }
    focusRangeInput() {
        this.input.nativeElement.focus();
        this.visibility = true;
    }
    blurRangeInput() {
        this.input.nativeElement.blur();
        this.visibility = false;
    }
    coverage(event) {
        if (typeof this.range === 'string' && this.range.length !== 0) {
            return this.range;
        }
        if (!this.default) {
            const newValue = event.target.value;
            const newRelativeGain = newValue - this.min;
            const inputWidth = this.input.nativeElement.offsetWidth;
            let thumbOffset = 0;
            const offsetAmmount = 15;
            const distanceFromMiddle = newRelativeGain - this.steps / 2;
            this.stepLength = inputWidth / this.steps;
            thumbOffset = (distanceFromMiddle / this.steps) * offsetAmmount;
            this.cloudRange = this.stepLength * newRelativeGain - thumbOffset;
            this.renderer.setStyle(this.rangeCloud.nativeElement, 'left', this.cloudRange + 'px');
        }
    }
    checkIfSafari() {
        const isSafari = navigator.userAgent.indexOf('Safari') > -1;
        const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
        const isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
        const isOpera = navigator.userAgent.indexOf('Opera') > -1;
        if (isSafari && !isChrome && !isFirefox && !isOpera) {
            return true;
        }
        else {
            return false;
        }
    }
    ngAfterViewInit() {
        this.steps = this.max - this.min;
        if (this.value) {
            this.range = this.value;
            this.cdRef.detectChanges();
        }
    }
    writeValue(value) {
        this.value = value;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
MdbColorPickerAlphaSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdb-color-picker-alpha-slider',
                template: "<div *ngIf=\"!default\" class=\"range-field\" #rangeField>\n    <div class=\"track\">\n      <div #rangeCloud class=\"range-cloud\" title=\"range\" [ngClass]=\"{'visible': this.visibility, 'hidden': !this.visibility}\">\n        <span class=\"text-transform\">{{range}}</span>\n      </div>\n    </div>\n    <input #input\n    [name]=\"name\"\n    type=\"range\"\n    [disabled]=\"disabled\"\n    [id]=\"id\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [value]=\"value\"\n    [(ngModel)]=\"range\"\n    (focus)=\"this.visibility = true\"\n    (blur)=\"this.visibility = false\"\n    (input)=\"coverage($event)\">\n</div>\n\n<div *ngIf=\"default\">\n    <input #input\n    class=\"custom-range\"\n    [name]=\"name\"\n    type=\"range\"\n    [id]=\"id\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [attr.value]=\"value\"\n    [value]=\"value\"\n    [(ngModel)]=\"range\"\n    (focus)=\"this.visibility = true\"\n    (blur)=\"this.visibility = false\"\n    (input)=\"coverage($event)\">\n    <!--<span class=\"{{defaultRangeCounterClass}}\">{{ range }}</span>-->\n  </div>\n",
                providers: [RANGE_VALUE_ACCESOR]
            },] }
];
MdbColorPickerAlphaSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
MdbColorPickerAlphaSliderComponent.propDecorators = {
    input: [{ type: ViewChild, args: ['input',] }],
    rangeCloud: [{ type: ViewChild, args: ['rangeCloud',] }],
    rangeField: [{ type: ViewChild, args: ['rangeField',] }],
    id: [{ type: Input }],
    required: [{ type: Input }],
    name: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    default: [{ type: Input }],
    defaultRangeCounterClass: [{ type: Input }],
    rangeValueChange: [{ type: Output }],
    onchange: [{ type: HostListener, args: ['change', ['$event'],] }],
    oninput: [{ type: HostListener, args: ['input', ['$event'],] }],
    onclick: [{ type: HostListener, args: ['click',] }],
    onmouseleave: [{ type: HostListener, args: ['mouseleave',] }]
};

class MdbColorPickerToggleDirective {
    constructor(renderer) {
        this.renderer = renderer;
        this.transitionTime = 200;
        this._isPickerVisible = false;
        this._clickEventTarget = null;
    }
    onClick(event) {
        this._clickEventTarget = event.target;
        this.toggleColorPicker();
    }
    onWindowClick(event) {
        if (event.target !== this._clickEventTarget &&
            this._isPickerVisible &&
            !this._getClosestEl(event.target, 'mdb-color-picker')) {
            this.toggleColorPicker();
        }
    }
    toggleColorPicker() {
        const opacityStyle = this._isPickerVisible ? '0' : '1';
        const visibilityStyle = this._isPickerVisible ? 'hidden' : 'visible';
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'transition', `opacity ${this.transitionTime}ms`);
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'opacity', opacityStyle);
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'visibility', 'visible');
        setTimeout(() => {
            this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'visibility', visibilityStyle);
        }, this.transitionTime);
        this._isPickerVisible = !this._isPickerVisible;
    }
    _getClosestEl(el, selector) {
        for (; el && el !== document; el = el.parentNode) {
            if (el.matches && el.matches(selector)) {
                return el;
            }
        }
        return null;
    }
}
MdbColorPickerToggleDirective.decorators = [
    { type: Directive, args: [{ selector: '[mdbColorPickerToggle]' },] }
];
MdbColorPickerToggleDirective.ctorParameters = () => [
    { type: Renderer2 }
];
MdbColorPickerToggleDirective.propDecorators = {
    mdbColorPickerToggle: [{ type: Input }],
    transitionTime: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onWindowClick: [{ type: HostListener, args: ['window:click', ['$event'],] }]
};

class MdbColorPickerModule {
}
MdbColorPickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    MdbColorPickerComponent,
                    MdbColorSliderComponent,
                    MdbColorPaletteComponent,
                    MdbColorDraggableDirective,
                    MdbColorPickerToggleDirective,
                    MdbColorPickerAlphaSliderComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                ],
                exports: [
                    MdbColorPickerComponent,
                    MdbColorSliderComponent,
                    MdbColorPaletteComponent,
                    MdbColorDraggableDirective,
                    MdbColorPickerToggleDirective,
                    MdbColorPickerAlphaSliderComponent
                ],
                providers: [
                    MdbColorPickerService
                ]
            },] }
];

/*
 * Public API Surface of mdb-color-picker
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbColorDraggableDirective, MdbColorPaletteComponent, MdbColorPickerAlphaSliderComponent, MdbColorPickerComponent, MdbColorPickerModule, MdbColorPickerService, MdbColorPickerToggleDirective, MdbColorSliderComponent, RANGE_VALUE_ACCESOR };
//# sourceMappingURL=mdb-color-picker.js.map
