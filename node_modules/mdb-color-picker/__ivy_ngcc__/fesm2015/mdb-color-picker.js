import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Component, Renderer2, Inject, PLATFORM_ID, Input, Output, ViewChild, HostListener, ChangeDetectorRef, ElementRef, Directive, HostBinding, forwardRef, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { takeUntil } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/forms';

const _c0 = ["canvas"];
function MdbColorPickerComponent_div_0_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵelementStart(2, "mdb-color-picker-alpha-slider", 15);
    ɵngcc0.ɵɵlistener("input", function MdbColorPickerComponent_div_0_div_8_Template_mdb_color_picker_alpha_slider_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ctx_r4.onAlphaInput($event); })("ngModelChange", function MdbColorPickerComponent_div_0_div_8_Template_mdb_color_picker_alpha_slider_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.opacityValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r1.alphaChannel)("ngModel", ctx_r1.opacityValue)("default", ctx_r1.defaultRangeSlider);
} }
const _c1 = function (a0) { return { "background-color": a0 }; };
function MdbColorPickerComponent_div_0_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵelement(1, "div", 17);
    ɵngcc0.ɵɵelementStart(2, "p", 18);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r2.colorString || "white"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.colorString);
} }
function MdbColorPickerComponent_div_0_div_16_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 21);
} if (rf & 2) {
    const i_r9 = ctx.index;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(1, _c1, ctx_r7.setColorPaletteCircleColor(i_r9)));
} }
function MdbColorPickerComponent_div_0_div_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "div", 19);
    ɵngcc0.ɵɵtemplate(2, MdbColorPickerComponent_div_0_div_16_div_2_Template, 1, 3, "div", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.colorPalette);
} }
function MdbColorPickerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵelementStart(2, "div", 3);
    ɵngcc0.ɵɵelementStart(3, "div", 4);
    ɵngcc0.ɵɵelementStart(4, "mdb-color-palette", 5);
    ɵngcc0.ɵɵlistener("color", function MdbColorPickerComponent_div_0_Template_mdb_color_palette_color_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.color = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 3);
    ɵngcc0.ɵɵelementStart(6, "div", 6);
    ɵngcc0.ɵɵelementStart(7, "mdb-color-slider", 7);
    ɵngcc0.ɵɵlistener("color", function MdbColorPickerComponent_div_0_Template_mdb_color_slider_color_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.hue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, MdbColorPickerComponent_div_0_div_8_Template, 3, 3, "div", 8);
    ɵngcc0.ɵɵelementStart(9, "div", 9);
    ɵngcc0.ɵɵelementStart(10, "div", 10);
    ɵngcc0.ɵɵtemplate(11, MdbColorPickerComponent_div_0_div_11_Template, 4, 4, "div", 11);
    ɵngcc0.ɵɵprojection(12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(13, "div", 9);
    ɵngcc0.ɵɵelementStart(14, "div", 12);
    ɵngcc0.ɵɵprojection(15, 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(16, MdbColorPickerComponent_div_0_div_16_Template, 3, 1, "div", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("hue", ctx_r0.hue);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.config.showOpacitySlider);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.config.showRgbaHexColorText);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.config.showPalette);
} }
const _c2 = [[["", 8, "color-picker-switch"]], [["", 8, "color-picker-buttons"]]];
const _c3 = [".color-picker-switch", ".color-picker-buttons"];
const _c4 = ["handle"];
const _c5 = ["slider"];
const _c6 = ["input"];
const _c7 = ["rangeCloud"];
const _c8 = ["rangeField"];
const _c9 = function (a0, a1) { return { "visible": a0, "hidden": a1 }; };
function MdbColorPickerAlphaSliderComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2, 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵelementStart(3, "div", 5, 6);
    ɵngcc0.ɵɵelementStart(5, "span", 7);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "input", 8, 9);
    ɵngcc0.ɵɵlistener("ngModelChange", function MdbColorPickerAlphaSliderComponent_div_0_Template_input_ngModelChange_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.range = $event; })("focus", function MdbColorPickerAlphaSliderComponent_div_0_Template_input_focus_7_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.visibility = true; })("blur", function MdbColorPickerAlphaSliderComponent_div_0_Template_input_blur_7_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.visibility = false; })("input", function MdbColorPickerAlphaSliderComponent_div_0_Template_input_input_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.coverage($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(10, _c9, ctx_r0.visibility, !ctx_r0.visibility));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.range);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.name)("disabled", ctx_r0.disabled)("id", ctx_r0.id)("min", ctx_r0.min)("max", ctx_r0.max)("step", ctx_r0.step)("value", ctx_r0.value)("ngModel", ctx_r0.range);
} }
function MdbColorPickerAlphaSliderComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "input", 10, 9);
    ɵngcc0.ɵɵlistener("ngModelChange", function MdbColorPickerAlphaSliderComponent_div_1_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.range = $event; })("focus", function MdbColorPickerAlphaSliderComponent_div_1_Template_input_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.visibility = true; })("blur", function MdbColorPickerAlphaSliderComponent_div_1_Template_input_blur_1_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.visibility = false; })("input", function MdbColorPickerAlphaSliderComponent_div_1_Template_input_input_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.coverage($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r1.name)("id", ctx_r1.id)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step)("value", ctx_r1.value)("ngModel", ctx_r1.range);
    ɵngcc0.ɵɵattribute("value", ctx_r1.value);
} }
class MdbColorPickerService {
    constructor() {
        this._segmentedColorChange = new Subject();
        this._alpha = '0.5';
        this._alphaChange = new Subject();
        this._coordsChange = new Subject();
        this._rgbaSegments = ['255', '255', '255', '0.5'];
        this._color = { rgbaColor: '', hexColor: '' };
        this._colorChange = new Subject();
        this._colorPalette = [];
        this._colorPaletteChange = new Subject();
    }
    setColorPalette(colorArray) {
        this._colorPalette = colorArray;
        this._colorPaletteChange.next(this.getColorPalette());
    }
    addColorToPalette(color) {
        this._colorPalette.push(color);
        this._colorPaletteChange.next(this.getColorPalette());
    }
    getColorPalette() {
        return this._colorPalette;
    }
    removeColorFromPalette(index) {
        this._colorPalette.splice(index, 1);
    }
    colorPaletteWasChanged() {
        return this._colorPaletteChange;
    }
    setColor(rgbaColor, hexColor) {
        this._color.rgbaColor = rgbaColor;
        this._color.hexColor = hexColor;
        this._colorChange.next(this.getColor());
    }
    getColor() {
        return this._color;
    }
    colorWasChanged() {
        return this._colorChange;
    }
    setSegmentedColor(value) {
        this._segmentedColor = value;
        this._segmentedColorChange.next(this.getSegmentedColor());
        const rgbaColor = this.convertToRGBA();
        const hexColor = this.rgbaToHex(this.getRgbaColor());
        this.setColor(rgbaColor, hexColor);
    }
    getSegmentedColor() {
        return this._segmentedColor;
    }
    colorSegmentedWasChanged() {
        return this._segmentedColorChange;
    }
    setAlpha(value) {
        this._alpha = value;
        this._alphaChange.next(this.getAlpha());
        const rgbaColor = this.convertToRGBA();
        const hexColor = this.rgbaToHex(this.getRgbaColor());
        this.setColor(rgbaColor, hexColor);
    }
    getAlpha() {
        return this._alpha;
    }
    alphaWasChanged() {
        return this._alphaChange;
    }
    setCoords(value) {
        this._coords = value;
        this._coordsChange.next(this.getCoords());
    }
    getCoords() {
        return this._coords;
    }
    coordsWasChanged() {
        return this._coordsChange;
    }
    convertToRGBA() {
        this._rgbaColor = this.getSegmentedColor().split(',');
        const alphaChannel = this.getAlpha();
        this._rgbaSegments[0] = this._rgbaColor[0];
        this._rgbaSegments[1] = this._rgbaColor[1];
        this._rgbaSegments[2] = this._rgbaColor[2];
        this._rgbaSegments[3] = alphaChannel;
        return 'rgba(' + this._rgbaSegments.toString() + ')';
    }
    getRgbaColor() {
        return this.convertToRGBA();
    }
    getHexColor() {
        return this.rgbaToHex(this.getSegmentedColor() + ',' + this.getAlpha());
    }
    rgbaToHex(value) {
        value = value.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return (value && value.length === 4) ? '#' +
            ('0' + parseInt(value[1], 10).toString(16)).slice(-2) +
            ('0' + parseInt(value[2], 10).toString(16)).slice(-2) +
            ('0' + parseInt(value[3], 10).toString(16)).slice(-2) : '';
    }
    hexToRgba(value, alpha) {
        const r = parseInt(value.slice(1, 3), 16);
        const g = parseInt(value.slice(3, 5), 16);
        const b = parseInt(value.slice(5, 7), 16);
        if (alpha) {
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        else {
            return `rgb(${r}, ${g}, ${b})`;
        }
    }
}
MdbColorPickerService.ɵfac = function MdbColorPickerService_Factory(t) { return new (t || MdbColorPickerService)(); };
MdbColorPickerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdbColorPickerService_Factory() { return new MdbColorPickerService(); }, token: MdbColorPickerService, providedIn: "root" });
MdbColorPickerService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPickerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class MdbColorPaletteComponent {
    constructor(renderer, colorService, platformId) {
        this.renderer = renderer;
        this.colorService = colorService;
        this.platformId = platformId;
        this.color = new EventEmitter(true);
        this.mousedown = false;
        this.isBrowser = false;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.colorService.coordsWasChanged().subscribe((data) => {
            this.getColorAtPosition(data.x, data.y);
            this.selectedPosition = { x: data.x, y: data.y };
            this.draw();
        });
        this.colorService.colorWasChanged().subscribe(() => {
            this.draw();
        });
    }
    onmouseup() {
        this.mousedown = false;
    }
    draw() {
        if (this.isBrowser) {
            if (!this.ctx) {
                this.ctx = this.canvas.nativeElement.getContext('2d');
            }
            setTimeout(() => {
                const canvasParentWidth = this.canvas.nativeElement.parentElement
                    .parentElement.clientWidth;
                this.renderer.setAttribute(this.canvas.nativeElement, 'width', canvasParentWidth + 'px');
                const width = this.canvas.nativeElement.clientWidth;
                const height = this.canvas.nativeElement.clientHeight;
                this.ctx.fillStyle = this.hue || 'rgba(255, 255, 255, 1)';
                this.ctx.fillRect(0, 0, width, height);
                const whiteGrad = this.ctx.createLinearGradient(0, 0, width, 0);
                whiteGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                whiteGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                this.ctx.fillStyle = whiteGrad;
                this.ctx.fillRect(0, 0, width, height);
                const blackGrad = this.ctx.createLinearGradient(0, 0, 0, height);
                blackGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                blackGrad.addColorStop(1, 'rgba(0, 0, 0, 1)');
                this.ctx.fillStyle = blackGrad;
                this.ctx.fillRect(0, 0, width, height);
                if (this.selectedPosition) {
                    this.ctx.strokeStyle = 'white';
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 5, 0, 2 * Math.PI);
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }, 0);
        }
    }
    ngOnChanges(changes) {
        if (changes['hue']) {
            this.draw();
            const pos = this.selectedPosition;
            if (pos) {
                this.getColorAtPosition(pos.x, pos.y);
            }
        }
    }
    onMouseDown(event) {
        this.mousedown = true;
        if (event.type === 'touchstart') {
            const rect = event.target.getBoundingClientRect();
            this.selectedPosition = {
                x: event.targetTouches[0].pageX - rect.left,
                y: event.targetTouches[0].pageY - rect.top
            };
        }
        else if (event.type === 'mousedown') {
            this.selectedPosition = { x: event.offsetX, y: event.offsetY };
        }
        this.draw();
        this.getColorAtPosition(this.selectedPosition.x, this.selectedPosition.y);
    }
    onMouseMove(event) {
        if (this.mousedown) {
            if (event.type === 'touchmove') {
                event.preventDefault();
                const rect = event.target.getBoundingClientRect();
                this.selectedPosition = {
                    x: event.targetTouches[0].pageX - rect.left,
                    y: event.targetTouches[0].pageY - rect.top
                };
            }
            else if (event.type === 'mousemove') {
                this.selectedPosition = { x: event.offsetX, y: event.offsetY };
            }
            this.draw();
            this.getColorAtPosition(this.selectedPosition.x, this.selectedPosition.y);
        }
    }
    getColorAtPosition(x, y) {
        if (this.isBrowser) {
            const imageData = this.ctx.getImageData(x, y, 1, 1).data;
            this.colorService.setSegmentedColor(`${imageData[0]},${imageData[1]},${imageData[2]}`);
            return ('rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)');
        }
    }
    pickColorAtStart(x, y) {
        if (this.isBrowser) {
            this.selectedPosition = { x: x, y: y };
            this.ctx.strokeStyle = 'white';
            this.ctx.fillStyle = 'white';
            this.ctx.beginPath();
            this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 10, 0, 2 * Math.PI);
            this.ctx.lineWidth = 5;
            this.ctx.stroke();
            this.getColorAtPosition(x, y);
            this.colorService.setCoords({ x: x, y: y });
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.pickColorAtStart(195, 75);
            this.draw();
        }, 0);
    }
}
MdbColorPaletteComponent.ɵfac = function MdbColorPaletteComponent_Factory(t) { return new (t || MdbColorPaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(MdbColorPickerService), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
MdbColorPaletteComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbColorPaletteComponent, selectors: [["mdb-color-palette"]], viewQuery: function MdbColorPaletteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.canvas = _t.first);
    } }, hostBindings: function MdbColorPaletteComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseup", function MdbColorPaletteComponent_mouseup_HostBindingHandler() { return ctx.onmouseup(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { hue: "hue" }, outputs: { color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 0, consts: [[1, "color-palette", 3, "mousedown", "touchstart", "touchmove", "mousemove"], ["canvas", ""]], template: function MdbColorPaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "canvas", 0, 1);
        ɵngcc0.ɵɵlistener("mousedown", function MdbColorPaletteComponent_Template_canvas_mousedown_0_listener($event) { return ctx.onMouseDown($event); })("touchstart", function MdbColorPaletteComponent_Template_canvas_touchstart_0_listener($event) { return ctx.onMouseDown($event); })("touchmove", function MdbColorPaletteComponent_Template_canvas_touchmove_0_listener($event) { return ctx.onMouseMove($event); })("mousemove", function MdbColorPaletteComponent_Template_canvas_mousemove_0_listener($event) { return ctx.onMouseMove($event); });
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [".color-palette[_ngcontent-%COMP%]:hover{cursor:pointer}"] });
MdbColorPaletteComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: MdbColorPickerService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
MdbColorPaletteComponent.propDecorators = {
    hue: [{ type: Input }],
    color: [{ type: Output }],
    canvas: [{ type: ViewChild, args: ['canvas', { static: true },] }],
    onmouseup: [{ type: HostListener, args: ['window:mouseup',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPaletteComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-color-palette',
                template: "<canvas #canvas class=\"color-palette\" (mousedown)=\"onMouseDown($event)\" (touchstart)=\"onMouseDown($event)\" (touchmove)=\"onMouseMove($event)\" (mousemove)=\"onMouseMove($event)\">\n</canvas>\n",
                styles: [".color-palette:hover{cursor:pointer}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: MdbColorPickerService }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { color: [{
            type: Output
        }], onmouseup: [{
            type: HostListener,
            args: ['window:mouseup']
        }], hue: [{
            type: Input
        }], canvas: [{
            type: ViewChild,
            args: ['canvas', { static: true }]
        }] }); })();

class MdbColorPickerComponent {
    constructor(colorService, cdRef, el, renderer) {
        this.colorService = colorService;
        this.cdRef = cdRef;
        this.el = el;
        this.renderer = renderer;
        this.colorPalette = [];
        this.defaultRangeSlider = true;
        this.config = {
            showPalette: true,
            showOpacitySlider: true,
            showRgbaHexColorText: true
        };
        this.alphaChannel = '0.5';
        this.opacityValue = '';
        this.colorSegments = ['255', '255', '255', '1'];
        this.switchValue = false;
        this.isBrowser = false;
        this.showPicker = false;
        this.componentDestroyed = new Subject();
        this.colorService
            .colorSegmentedWasChanged()
            .pipe(takeUntil(this.componentDestroyed))
            .subscribe((data) => {
            this.colorString =
                'rgba(' + data.split(',') + ', ' + this.alphaChannel + ')';
            this.color = this.colorService.getSegmentedColor();
            this.color = this.color.split(',');
            this.change();
            this.cdRef.detectChanges();
        });
        this.colorService.alphaWasChanged().subscribe(() => {
            this.alphaChannel = this.colorService.getAlpha();
        });
        this.colorService.coordsWasChanged().subscribe(() => {
            this.colorService.colorWasChanged().subscribe((color) => {
                if (this.switchValue === false) {
                    this.colorString = color.rgbaColor;
                }
                else {
                    this.colorString = color.hexColor;
                }
            });
        });
        this.colorService.colorPaletteWasChanged().subscribe((data) => {
            this.colorPalette = data;
        });
        // Resolves problem with hidden canvas of color picker and color slider
        // when color picker component was placed inside of static modal
        this.observer = new MutationObserver(mutations => {
            mutations.forEach((mutation) => {
                const stylesAttribute = mutation.target.getAttribute('style');
                if (stylesAttribute) {
                    this.showPicker = stylesAttribute.includes('visibility: visible');
                    this.cdRef.detectChanges();
                }
            });
        });
        this.observer.observe(this.el.nativeElement, {
            attributes: true,
            childList: true,
            characterData: true
        });
    }
    setOptions() {
        if (this.options !== undefined) {
            Object.keys(this.options).forEach((k) => {
                this.config[k] = this.options[k];
            });
        }
    }
    onAlphaInput(event) {
        this.colorService.setAlpha(event.target.value);
        this.colorSegments[0] = this.color[0];
        this.colorSegments[1] = this.color[1];
        this.colorSegments[2] = this.color[2];
        this.colorSegments[3] = this.alphaChannel;
        this.colorString = 'rgba(' + this.colorSegments.toString() + ')';
        this.change();
    }
    copyToClipboard(type) {
        const el = this.renderer.createElement('textarea');
        if (type === 'color') {
            el.value = this.colorString;
        }
        else if (type === 'palette') {
            this.colorService.getColorPalette().forEach((color) => {
                el.value += '{';
                el.value += 'rgbaColor: ' + `'${color.rgbaColor}'` + ', ';
                el.value += 'hexColor: ' + `'${color.hexColor}'`;
                el.value += '}, ';
            });
        }
        this.renderer.setAttribute(el, 'readonly', '');
        this.renderer.setStyle(el, 'position', 'absolute');
        this.renderer.setStyle(el, 'left', '-9999px');
        this.renderer.appendChild(document.body, el);
        el.select();
        document.execCommand('copy');
        this.renderer.removeChild(document.body, el);
    }
    clearColor() {
        if (this.colorService.getCoords()) {
            this.colorService.setCoords({
                x: this.colorService.getCoords().x,
                y: this.colorService.getCoords().y
            });
        }
        else {
            this.colorService.setCoords({ x: 122, y: 137 });
        }
        this.change();
        if (this.colorService.getAlpha() !== '0.5') {
            this.colorService.setAlpha(this.colorService.getAlpha());
        }
        else {
            this.colorService.setAlpha('0.5');
        }
        this.colorService.setColorPalette([]);
    }
    addColorToPalette() {
        this.colorService.addColorToPalette({
            rgbaColor: this.colorService.getColor().rgbaColor,
            hexColor: this.colorService.getColor().hexColor
        });
        this.colorPalette = this.colorService.getColorPalette();
    }
    setColorPaletteCircleColor(index) {
        if (!this.switchValue) {
            return this.colorPalette[index].rgbaColor;
        }
        else if (this.switchValue) {
            return this.colorPalette[index].hexColor;
        }
    }
    changeColorSystemTo(colorSystem) {
        if (colorSystem === 'rgba') {
            this.colorString = this.colorService.getColor().rgbaColor;
            return 'rgba';
        }
        else {
            this.colorString = this.colorService.getColor().hexColor;
            return 'hex';
        }
    }
    change() {
        if (!this.switchValue) {
            this.changeColorSystemTo('rgba');
        }
        else {
            this.changeColorSystemTo('hex');
        }
    }
    changeColorType() {
        this.switchValue = !this.switchValue;
        this.change();
    }
    ngAfterViewInit() {
        this.changeColorSystemTo('rgba');
        if (this.colorPalette) {
            this.colorService.setColorPalette(this.colorPalette);
        }
        this.setOptions();
        this.cdRef.detectChanges();
    }
    ngOnDestroy() {
        this.observer.disconnect();
        this.componentDestroyed.next();
        this.componentDestroyed.complete();
    }
}
MdbColorPickerComponent.ɵfac = function MdbColorPickerComponent_Factory(t) { return new (t || MdbColorPickerComponent)(ɵngcc0.ɵɵdirectiveInject(MdbColorPickerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
MdbColorPickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbColorPickerComponent, selectors: [["mdb-color-picker"]], inputs: { colorPalette: "colorPalette", defaultRangeSlider: "defaultRangeSlider", options: "options" }, exportAs: ["mdb-color-picker"], ngContentSelectors: _c3, decls: 1, vars: 1, consts: [["class", "card d-flex", 4, "ngIf"], [1, "card", "d-flex"], [1, "card-body", "color-picker-card", "flex-column", "flex-center"], [1, "row", "w-100"], [1, "col-md-12", "w-100", "d-flex", "flex-column", "flex-center"], [3, "hue", "color"], [1, "col-md-12", "py-2", "d-flex"], [3, "color"], ["class", "row w-100", 4, "ngIf"], [1, "row"], [1, "col-md-12", "d-flex", "flex-center", "flex-column"], ["class", "flex-row py-2 flex-center", 4, "ngIf"], [1, "col-md-12", "d-flex", "flex-center", "text-center"], ["class", "row", 4, "ngIf"], [1, "col-md-12", "py-2", "d-flex", "p-0"], ["id", "range", "min", "0", "max", "1", "step", "0.01", 1, "w-100", 3, "value", "ngModel", "default", "input", "ngModelChange"], [1, "flex-row", "py-2", "flex-center"], [1, "color-div", "z-depth-1", "mx-2", 3, "ngStyle"], [1, ""], [1, "col-md-12", "d-flex", "flex-center", "text-center", "flex-wrap"], ["class", "color-palette-circle m-1 d-flex flex-center", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "color-palette-circle", "m-1", "d-flex", "flex-center", 3, "ngStyle"]], template: function MdbColorPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵtemplate(0, MdbColorPickerComponent_div_0_Template, 17, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showPicker);
    } }, directives: function () { return [ɵngcc1.NgIf, MdbColorPaletteComponent, MdbColorSliderComponent, MdbColorPickerAlphaSliderComponent, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ɵngcc1.NgStyle, ɵngcc1.NgForOf]; }, styles: [".input-wrapper[_ngcontent-%COMP%]{margin-top:16px;display:flex;border-radius:1px;border:1px solid gainsboro;padding:8px;height:32px;justify-content:center}.color-div[_ngcontent-%COMP%]{width:1rem;height:1rem;border-radius:50%}.color-slider-text[_ngcontent-%COMP%]{margin-top:-5px}.switch.primary-switch[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%]:checked + .lever[_ngcontent-%COMP%]{background-color:#689df6}.switch[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%]:checked + .lever[_ngcontent-%COMP%]:after{background-color:#4285f4}.color-palette-circle[_ngcontent-%COMP%]{width:2rem;height:2rem;border-radius:50%}"] });
MdbColorPickerComponent.ctorParameters = () => [
    { type: MdbColorPickerService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 }
];
MdbColorPickerComponent.propDecorators = {
    colorPalette: [{ type: Input }],
    options: [{ type: Input }],
    defaultRangeSlider: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPickerComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-color-picker',
                template: "<div class=\"card d-flex\" *ngIf=\"showPicker\">\n\n  <div class=\"card-body color-picker-card flex-column flex-center\">\n    <div class=\"row w-100\">\n      <div class=\"col-md-12 w-100 d-flex flex-column flex-center\">\n        <mdb-color-palette [hue]=\"hue\" (color)=\"color = $event\"></mdb-color-palette>\n      </div>\n    </div>\n\n    <div class=\"row w-100\">\n      <div class=\"col-md-12 py-2 d-flex\">\n        <mdb-color-slider (color)=\"hue = $event\"></mdb-color-slider>\n      </div>\n    </div>\n\n    <div class=\"row w-100\" *ngIf=\"config.showOpacitySlider\">\n      <div class=\"col-md-12 py-2 d-flex p-0\">\n        <mdb-color-picker-alpha-slider\n          class=\"w-100\"\n          id=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.01\"\n          [value]=\"alphaChannel\"\n          (input)=\"onAlphaInput($event)\"\n          [(ngModel)]=\"opacityValue\"\n          [default]=\"defaultRangeSlider\">\n        </mdb-color-picker-alpha-slider>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 d-flex flex-center flex-column\">\n        <div class=\"flex-row py-2 flex-center\" *ngIf=\"config.showRgbaHexColorText\">\n          <div class=\"color-div z-depth-1 mx-2\" [ngStyle]=\"{'background-color': colorString || 'white'}\"></div>\n          <p class=\"\">{{colorString}}</p>\n        </div>\n        <ng-content select=\".color-picker-switch\"></ng-content>\n      </div>\n\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col-md-12 d-flex flex-center text-center\">\n        <ng-content select=\".color-picker-buttons\"></ng-content>\n      </div>\n    </div>\n\n    <div class=\"row\" *ngIf=\"config.showPalette\">\n      <div class=\"col-md-12 d-flex flex-center text-center flex-wrap\">\n        <div class=\"color-palette-circle m-1 d-flex flex-center\"\n             [ngStyle]=\"{'background-color': setColorPaletteCircleColor(i)}\"\n             *ngFor=\"let color of colorPalette; let i = index\">\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n",
                exportAs: 'mdb-color-picker',
                styles: [".input-wrapper{margin-top:16px;display:flex;border-radius:1px;border:1px solid gainsboro;padding:8px;height:32px;justify-content:center}.color-div{width:1rem;height:1rem;border-radius:50%}.color-slider-text{margin-top:-5px}.switch.primary-switch label input[type=checkbox]:checked+.lever{background-color:#689df6}.switch label input[type=checkbox]:checked+.lever:after{background-color:#4285f4}.color-palette-circle{width:2rem;height:2rem;border-radius:50%}\n"]
            }]
    }], function () { return [{ type: MdbColorPickerService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { colorPalette: [{
            type: Input
        }], defaultRangeSlider: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();

class MdbColorDraggableDirective {
    constructor(el) {
        this.el = el;
        this.elementPosition = { x: 0 };
        this.movable = true;
    }
    onStartMove(event) {
        this.isElementMoving = true;
        this.startMoving(event);
    }
    onMove(event) {
        if (!this.isElementMoving) {
            return;
        }
        this.movingOver(event);
    }
    onEndMove() {
        if (!this.isElementMoving) {
            return;
        }
        this.isElementMoving = false;
    }
    startMoving(event) {
        if (event.type === 'mousedown') {
            this.startingPosition = {
                x: event.clientX - this.elementPosition.x
            };
        }
        else {
            this.startingPosition = {
                x: event.changedTouches[0].clientX - this.elementPosition.x
            };
        }
    }
    movingOver(event) {
        if (event.type === 'mousemove') {
            this.elementPosition.x = event.clientX - this.startingPosition.x;
        }
        else {
            this.elementPosition.x =
                event.changedTouches[0].clientX - this.startingPosition.x;
        }
        this.updatePosition();
    }
    moveTo(value) {
        this.elementPosition.x = value;
        this.updatePosition();
    }
    updatePosition() {
        if (this.elementPosition.x >= 1 &&
            this.elementPosition.x <= this.el.nativeElement.parentElement.offsetWidth) {
            requestAnimationFrame(() => {
                this.el.nativeElement.style.transform = `
                translateX(${this.elementPosition.x}px)
              `;
            });
        }
    }
}
MdbColorDraggableDirective.ɵfac = function MdbColorDraggableDirective_Factory(t) { return new (t || MdbColorDraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MdbColorDraggableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbColorDraggableDirective, selectors: [["", "mdbColorDraggable", ""]], hostVars: 2, hostBindings: function MdbColorDraggableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function MdbColorDraggableDirective_mousedown_HostBindingHandler($event) { return ctx.onStartMove($event); })("touchstart", function MdbColorDraggableDirective_touchstart_HostBindingHandler($event) { return ctx.onStartMove($event); })("mousemove", function MdbColorDraggableDirective_mousemove_HostBindingHandler($event) { return ctx.onMove($event); }, false, ɵngcc0.ɵɵresolveDocument)("touchmove", function MdbColorDraggableDirective_touchmove_HostBindingHandler($event) { return ctx.onMove($event); })("mouseup", function MdbColorDraggableDirective_mouseup_HostBindingHandler() { return ctx.onEndMove(); }, false, ɵngcc0.ɵɵresolveDocument)("touchend", function MdbColorDraggableDirective_touchend_HostBindingHandler() { return ctx.onEndMove(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mdb-movable", ctx.movable);
    } } });
MdbColorDraggableDirective.ctorParameters = () => [
    { type: ElementRef }
];
MdbColorDraggableDirective.propDecorators = {
    movable: [{ type: HostBinding, args: ['class.mdb-movable',] }],
    onStartMove: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }],
    onMove: [{ type: HostListener, args: ['document:mousemove', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }],
    onEndMove: [{ type: HostListener, args: ['document:mouseup',] }, { type: HostListener, args: ['touchend',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorDraggableDirective, [{
        type: Directive,
        args: [{
                selector: '[mdbColorDraggable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { movable: [{
            type: HostBinding,
            args: ['class.mdb-movable']
        }], onStartMove: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }, {
            type: HostListener,
            args: ['touchstart', ['$event']]
        }], onMove: [{
            type: HostListener,
            args: ['document:mousemove', ['$event']]
        }, {
            type: HostListener,
            args: ['touchmove', ['$event']]
        }], onEndMove: [{
            type: HostListener,
            args: ['document:mouseup']
        }, {
            type: HostListener,
            args: ['touchend']
        }] }); })();

class MdbColorSliderComponent {
    constructor(renderer, el, platformId) {
        this.renderer = renderer;
        this.el = el;
        this.platformId = platformId;
        this.color = new EventEmitter();
        this.mousedown = false;
        this.previousImageData = null;
        this.isBrowser = false;
        this.isBrowser = isPlatformBrowser(this.platformId);
    }
    handleMouseDown() {
        if (this.isBrowser) {
            this.mousedown = true;
            this.renderer.addClass(this.handle.nativeElement, 'pop');
            this.renderer.addClass(this.slider.nativeElement, 'grad');
            this.renderer.setStyle(this.canvas.nativeElement, 'margin-left', '-13px');
        }
    }
    moveColorCircleToPosition(event) {
        const rect = event.target.getBoundingClientRect();
        let pos = null;
        if (event.type === 'touchmove') {
            event.preventDefault();
            this.drag.moveTo(event.targetTouches[0].pageX - rect.left);
            this.drag.elementPosition.x = event.targetTouches[0].pageX - rect.left;
            pos = {
                x: event.targetTouches[0].pageX -
                    this.slider.nativeElement.getBoundingClientRect().left,
                y: event.targetTouches[0].pageY -
                    this.slider.nativeElement.getBoundingClientRect().top
            };
        }
        else if (event.type === 'click') {
            this.drag.moveTo(event.layerX);
            this.drag.elementPosition.x = event.layerX;
            pos = {
                x: event.x - this.slider.nativeElement.getBoundingClientRect().x,
                y: event.y - this.slider.nativeElement.getBoundingClientRect().y
            };
        }
        if (pos !== null) {
            this.draw();
            this.emitColor(pos.x, pos.y);
            this.renderer.setStyle(this.handle.nativeElement, 'background-color', this.getColorAtPosition(pos.x, pos.y));
        }
    }
    handleMouseUp() {
        this.mousedown = false;
        this.renderer.removeClass(this.handle.nativeElement, 'pop');
        this.renderer.removeClass(this.slider.nativeElement, 'grad');
    }
    handleMouseMove(event) {
        if (this.mousedown) {
            let left = 0;
            let pos = null;
            if (event.type === 'touchmove') {
                event.preventDefault();
                left =
                    event.targetTouches[0].pageX -
                        this.slider.nativeElement.getBoundingClientRect().left +
                        5;
                const rect = event.target.getBoundingClientRect();
                pos = {
                    x: event.targetTouches[0].pageX - rect.left,
                    y: event.targetTouches[0].pageY - rect.top
                };
            }
            else if (event.type === 'mousemove') {
                left =
                    event.clientX -
                        this.slider.nativeElement.getBoundingClientRect().left +
                        5;
                pos = {
                    x: event.x - this.slider.nativeElement.getBoundingClientRect().x,
                    y: event.y - this.slider.nativeElement.getBoundingClientRect().y
                };
            }
            if (left <= this.sliderParent.clientWidth && pos !== null) {
                this.draw();
                this.emitColor(pos.x, pos.y);
                this.renderer.setStyle(this.handle.nativeElement, 'background-color', this.getColorAtPosition(pos.x, pos.y));
            }
        }
    }
    draw() {
        if (this.isBrowser) {
            if (!this.ctx) {
                this.ctx = this.canvas.nativeElement.getContext('2d');
            }
            setTimeout(() => {
                const width = this.sliderParent.clientWidth;
                const height = 12;
                this.renderer.setAttribute(this.canvas.nativeElement, 'width', width + 'px');
                let grd;
                grd = this.ctx.createLinearGradient(0.0, 150.0, width, 12);
                grd.addColorStop(0.0, 'rgba(255, 0, 0, 1.000)');
                grd.addColorStop(0.2, 'rgba(255, 0, 255, 1.000)');
                grd.addColorStop(0.35, 'rgba(0, 0, 255, 1.000)');
                grd.addColorStop(0.52, 'rgba(0, 255, 255, 1.000)');
                grd.addColorStop(0.71, 'rgba(0, 255, 0, 1.000)');
                grd.addColorStop(0.88, 'rgba(255, 255, 0, 1.000)');
                grd.addColorStop(1.0, 'rgba(255, 0, 148, 1.000)');
                this.ctx.fillStyle = grd;
                this.ctx.fillRect(0, 0, width, height);
            }, 0);
        }
    }
    ngAfterViewInit() {
        if (this.isBrowser) {
            this.sliderParent = this.slider.nativeElement.parentElement.parentElement.parentElement;
            this.renderer.setStyle(this.slider.nativeElement, 'width', this.sliderParent.clientWidth + 'px');
            this.draw();
            this.renderer.setStyle(this.canvas.nativeElement, 'margin-left', '-13px');
            this.setCanvasParentsWidth();
        }
    }
    setCanvasParentsWidth() {
        setTimeout(() => {
            this.renderer.setStyle(this.el.nativeElement, 'width', this.sliderParent.clientWidth + 'px');
        }, 0);
    }
    emitColor(x, y) {
        const rgbaColor = this.getColorAtPosition(x, y);
        this.color.emit(rgbaColor);
    }
    getColorAtPosition(x, y) {
        if (this.isBrowser) {
            const imageData = this.ctx.getImageData(x, y, 1, 1).data;
            if (imageData[0] + imageData[1] + imageData[2] > 0 ||
                this.previousImageData == null) {
                this.previousImageData = imageData;
            }
            else {
                return `rgba(${this.previousImageData[0]},${this.previousImageData[1]}, ${this.previousImageData[2]}, 1)`;
            }
            return ('rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)');
        }
    }
}
MdbColorSliderComponent.ɵfac = function MdbColorSliderComponent_Factory(t) { return new (t || MdbColorSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
MdbColorSliderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbColorSliderComponent, selectors: [["mdb-color-slider"]], viewQuery: function MdbColorSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 7);
        ɵngcc0.ɵɵviewQuery(_c5, 7);
        ɵngcc0.ɵɵviewQuery(_c0, 7);
        ɵngcc0.ɵɵviewQuery(MdbColorDraggableDirective, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.handle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slider = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.canvas = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drag = _t.first);
    } }, outputs: { color: "color" }, decls: 7, vars: 0, consts: [[1, "row"], [1, "col-md-12", "slider"], ["slider", ""], ["height", "12", 1, "color-slider", 3, "touchmove", "click", "mousedown", "touchstart", "mouseup", "touchend"], ["canvas", ""], ["mdbColorDraggable", "", 1, "handle", 3, "mousemove", "mousedown", "mouseup", "touchmove", "touchstart", "touchend"], ["handle", ""]], template: function MdbColorSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(3, "canvas", 3, 4);
        ɵngcc0.ɵɵlistener("touchmove", function MdbColorSliderComponent_Template_canvas_touchmove_3_listener($event) { return ctx.moveColorCircleToPosition($event); })("click", function MdbColorSliderComponent_Template_canvas_click_3_listener($event) { return ctx.moveColorCircleToPosition($event); })("mousedown", function MdbColorSliderComponent_Template_canvas_mousedown_3_listener() { return ctx.handleMouseDown(); })("touchstart", function MdbColorSliderComponent_Template_canvas_touchstart_3_listener() { return ctx.handleMouseDown(); })("mouseup", function MdbColorSliderComponent_Template_canvas_mouseup_3_listener() { return ctx.handleMouseUp(); })("touchend", function MdbColorSliderComponent_Template_canvas_touchend_3_listener() { return ctx.handleMouseUp(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 5, 6);
        ɵngcc0.ɵɵlistener("mousemove", function MdbColorSliderComponent_Template_div_mousemove_5_listener($event) { return ctx.handleMouseMove($event); })("mousedown", function MdbColorSliderComponent_Template_div_mousedown_5_listener() { return ctx.handleMouseDown(); })("mouseup", function MdbColorSliderComponent_Template_div_mouseup_5_listener() { return ctx.handleMouseUp(); })("touchmove", function MdbColorSliderComponent_Template_div_touchmove_5_listener($event) { return ctx.handleMouseMove($event); })("touchstart", function MdbColorSliderComponent_Template_div_touchstart_5_listener() { return ctx.handleMouseDown(); })("touchend", function MdbColorSliderComponent_Template_div_touchend_5_listener() { return ctx.handleMouseUp(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, directives: [MdbColorDraggableDirective], styles: [".color-slider[_ngcontent-%COMP%]:hover{cursor:pointer}.slider[_ngcontent-%COMP%]{position:relative;width:100%;height:12px;border-radius:2px}.color-slider[_ngcontent-%COMP%]{margin-bottom:10px}.handle[_ngcontent-%COMP%]{position:absolute;top:-8px;left:0;width:24px;height:24px;border-radius:12px;background:red;transition:box-shadow .2s}.handle[_ngcontent-%COMP%]:before{content:\"\";position:absolute;top:8px;left:50%;margin-left:-2px;background:inherit;width:4px;height:4px;border-radius:20px;transition:top .2s,left .2s,margin-left .2s,height .2s,width .2s}.handle.pop[_ngcontent-%COMP%]:before{top:-50px;left:50%;margin-left:-20px;background:inherit;width:40px;height:40px;border-radius:20px;box-shadow:0 4px 10px #0000004d}"] });
MdbColorSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
MdbColorSliderComponent.propDecorators = {
    handle: [{ type: ViewChild, args: ['handle', { static: true },] }],
    slider: [{ type: ViewChild, args: ['slider', { static: true },] }],
    canvas: [{ type: ViewChild, args: ['canvas', { static: true },] }],
    drag: [{ type: ViewChild, args: [MdbColorDraggableDirective, { static: true },] }],
    color: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorSliderComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-color-slider',
                template: "<div class=\"row\">\n  <div class=\"col-md-12 slider\" #slider>\n    <canvas #canvas class=\"color-slider\" height=\"12\"\n            (touchmove)=\"moveColorCircleToPosition($event)\"\n            (click)=\"moveColorCircleToPosition($event)\"\n            (mousedown)=\"handleMouseDown()\"\n            (touchstart)=\"handleMouseDown()\"\n            (mouseup)=\"handleMouseUp()\"\n            (touchend)=\"handleMouseUp()\">\n    </canvas>\n    <div class=\"handle\" #handle\n         (mousemove)=\"handleMouseMove($event)\"\n         (mousedown)=\"handleMouseDown()\"\n         (mouseup)=\"handleMouseUp()\"\n         (touchmove)=\"handleMouseMove($event)\"\n         (touchstart)=\"handleMouseDown()\"\n         (touchend)=\"handleMouseUp()\"\n         mdbColorDraggable></div>\n  </div>\n</div>\n",
                styles: [".color-slider:hover{cursor:pointer}.slider{position:relative;width:100%;height:12px;border-radius:2px}.color-slider{margin-bottom:10px}.handle{position:absolute;top:-8px;left:0;width:24px;height:24px;border-radius:12px;background:red;transition:box-shadow .2s}.handle:before{content:\"\";position:absolute;top:8px;left:50%;margin-left:-2px;background:inherit;width:4px;height:4px;border-radius:20px;transition:top .2s,left .2s,margin-left .2s,height .2s,width .2s}.handle.pop:before{top:-50px;left:50%;margin-left:-20px;background:inherit;width:40px;height:40px;border-radius:20px;box-shadow:0 4px 10px #0000004d}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { color: [{
            type: Output
        }], handle: [{
            type: ViewChild,
            args: ['handle', { static: true }]
        }], slider: [{
            type: ViewChild,
            args: ['slider', { static: true }]
        }], canvas: [{
            type: ViewChild,
            args: ['canvas', { static: true }]
        }], drag: [{
            type: ViewChild,
            args: [MdbColorDraggableDirective, { static: true }]
        }] }); })();

const RANGE_VALUE_ACCESOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdbColorPickerAlphaSliderComponent),
    multi: true
};
class MdbColorPickerAlphaSliderComponent {
    constructor(renderer, cdRef) {
        this.renderer = renderer;
        this.cdRef = cdRef;
        this.min = 0;
        this.max = 100;
        this.rangeValueChange = new EventEmitter();
        this.range = 0;
        this.cloudRange = 0;
        this.visibility = false;
        // Control Value Accessor Methods
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    onchange(event) {
        this.onChange(event.target.value);
    }
    oninput(event) {
        const value = +event.target.value;
        this.rangeValueChange.emit({ value: value });
        if (this.checkIfSafari()) {
            this.focusRangeInput();
        }
    }
    onclick() {
        this.focusRangeInput();
    }
    onmouseleave() {
        if (this.checkIfSafari()) {
            this.blurRangeInput();
        }
    }
    focusRangeInput() {
        this.input.nativeElement.focus();
        this.visibility = true;
    }
    blurRangeInput() {
        this.input.nativeElement.blur();
        this.visibility = false;
    }
    coverage(event) {
        if (typeof this.range === 'string' && this.range.length !== 0) {
            return this.range;
        }
        if (!this.default) {
            const newValue = event.target.value;
            const newRelativeGain = newValue - this.min;
            const inputWidth = this.input.nativeElement.offsetWidth;
            let thumbOffset = 0;
            const offsetAmmount = 15;
            const distanceFromMiddle = newRelativeGain - this.steps / 2;
            this.stepLength = inputWidth / this.steps;
            thumbOffset = (distanceFromMiddle / this.steps) * offsetAmmount;
            this.cloudRange = this.stepLength * newRelativeGain - thumbOffset;
            this.renderer.setStyle(this.rangeCloud.nativeElement, 'left', this.cloudRange + 'px');
        }
    }
    checkIfSafari() {
        const isSafari = navigator.userAgent.indexOf('Safari') > -1;
        const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
        const isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
        const isOpera = navigator.userAgent.indexOf('Opera') > -1;
        if (isSafari && !isChrome && !isFirefox && !isOpera) {
            return true;
        }
        else {
            return false;
        }
    }
    ngAfterViewInit() {
        this.steps = this.max - this.min;
        if (this.value) {
            this.range = this.value;
            this.cdRef.detectChanges();
        }
    }
    writeValue(value) {
        this.value = value;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
MdbColorPickerAlphaSliderComponent.ɵfac = function MdbColorPickerAlphaSliderComponent_Factory(t) { return new (t || MdbColorPickerAlphaSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
MdbColorPickerAlphaSliderComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbColorPickerAlphaSliderComponent, selectors: [["mdb-color-picker-alpha-slider"]], viewQuery: function MdbColorPickerAlphaSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c6, 5);
        ɵngcc0.ɵɵviewQuery(_c7, 5);
        ɵngcc0.ɵɵviewQuery(_c8, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeCloud = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rangeField = _t.first);
    } }, hostBindings: function MdbColorPickerAlphaSliderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("change", function MdbColorPickerAlphaSliderComponent_change_HostBindingHandler($event) { return ctx.onchange($event); })("input", function MdbColorPickerAlphaSliderComponent_input_HostBindingHandler($event) { return ctx.oninput($event); })("click", function MdbColorPickerAlphaSliderComponent_click_HostBindingHandler() { return ctx.onclick(); })("mouseleave", function MdbColorPickerAlphaSliderComponent_mouseleave_HostBindingHandler() { return ctx.onmouseleave(); });
    } }, inputs: { min: "min", max: "max", value: "value", disabled: "disabled", id: "id", required: "required", name: "name", step: "step", default: "default", defaultRangeCounterClass: "defaultRangeCounterClass" }, outputs: { rangeValueChange: "rangeValueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([RANGE_VALUE_ACCESOR])], decls: 2, vars: 2, consts: [["class", "range-field", 4, "ngIf"], [4, "ngIf"], [1, "range-field"], ["rangeField", ""], [1, "track"], ["title", "range", 1, "range-cloud", 3, "ngClass"], ["rangeCloud", ""], [1, "text-transform"], ["type", "range", 3, "name", "disabled", "id", "min", "max", "step", "value", "ngModel", "ngModelChange", "focus", "blur", "input"], ["input", ""], ["type", "range", 1, "custom-range", 3, "name", "id", "min", "max", "step", "value", "ngModel", "ngModelChange", "focus", "blur", "input"]], template: function MdbColorPickerAlphaSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MdbColorPickerAlphaSliderComponent_div_0_Template, 9, 13, "div", 0);
        ɵngcc0.ɵɵtemplate(1, MdbColorPickerAlphaSliderComponent_div_1_Template, 3, 8, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.default);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.default);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc2.RangeValueAccessor, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel], encapsulation: 2 });
MdbColorPickerAlphaSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
MdbColorPickerAlphaSliderComponent.propDecorators = {
    input: [{ type: ViewChild, args: ['input',] }],
    rangeCloud: [{ type: ViewChild, args: ['rangeCloud',] }],
    rangeField: [{ type: ViewChild, args: ['rangeField',] }],
    id: [{ type: Input }],
    required: [{ type: Input }],
    name: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    default: [{ type: Input }],
    defaultRangeCounterClass: [{ type: Input }],
    rangeValueChange: [{ type: Output }],
    onchange: [{ type: HostListener, args: ['change', ['$event'],] }],
    oninput: [{ type: HostListener, args: ['input', ['$event'],] }],
    onclick: [{ type: HostListener, args: ['click',] }],
    onmouseleave: [{ type: HostListener, args: ['mouseleave',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPickerAlphaSliderComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-color-picker-alpha-slider',
                template: "<div *ngIf=\"!default\" class=\"range-field\" #rangeField>\n    <div class=\"track\">\n      <div #rangeCloud class=\"range-cloud\" title=\"range\" [ngClass]=\"{'visible': this.visibility, 'hidden': !this.visibility}\">\n        <span class=\"text-transform\">{{range}}</span>\n      </div>\n    </div>\n    <input #input\n    [name]=\"name\"\n    type=\"range\"\n    [disabled]=\"disabled\"\n    [id]=\"id\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [value]=\"value\"\n    [(ngModel)]=\"range\"\n    (focus)=\"this.visibility = true\"\n    (blur)=\"this.visibility = false\"\n    (input)=\"coverage($event)\">\n</div>\n\n<div *ngIf=\"default\">\n    <input #input\n    class=\"custom-range\"\n    [name]=\"name\"\n    type=\"range\"\n    [id]=\"id\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [attr.value]=\"value\"\n    [value]=\"value\"\n    [(ngModel)]=\"range\"\n    (focus)=\"this.visibility = true\"\n    (blur)=\"this.visibility = false\"\n    (input)=\"coverage($event)\">\n    <!--<span class=\"{{defaultRangeCounterClass}}\">{{ range }}</span>-->\n  </div>\n",
                providers: [RANGE_VALUE_ACCESOR]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { min: [{
            type: Input
        }], max: [{
            type: Input
        }], rangeValueChange: [{
            type: Output
        }], onchange: [{
            type: HostListener,
            args: ['change', ['$event']]
        }], oninput: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], onclick: [{
            type: HostListener,
            args: ['click']
        }], onmouseleave: [{
            type: HostListener,
            args: ['mouseleave']
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input']
        }], rangeCloud: [{
            type: ViewChild,
            args: ['rangeCloud']
        }], rangeField: [{
            type: ViewChild,
            args: ['rangeField']
        }], id: [{
            type: Input
        }], required: [{
            type: Input
        }], name: [{
            type: Input
        }], step: [{
            type: Input
        }], default: [{
            type: Input
        }], defaultRangeCounterClass: [{
            type: Input
        }] }); })();

class MdbColorPickerToggleDirective {
    constructor(renderer) {
        this.renderer = renderer;
        this.transitionTime = 200;
        this._isPickerVisible = false;
        this._clickEventTarget = null;
    }
    onClick(event) {
        this._clickEventTarget = event.target;
        this.toggleColorPicker();
    }
    onWindowClick(event) {
        if (event.target !== this._clickEventTarget &&
            this._isPickerVisible &&
            !this._getClosestEl(event.target, 'mdb-color-picker')) {
            this.toggleColorPicker();
        }
    }
    toggleColorPicker() {
        const opacityStyle = this._isPickerVisible ? '0' : '1';
        const visibilityStyle = this._isPickerVisible ? 'hidden' : 'visible';
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'transition', `opacity ${this.transitionTime}ms`);
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'opacity', opacityStyle);
        this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'visibility', 'visible');
        setTimeout(() => {
            this.renderer.setStyle(this.mdbColorPickerToggle.el.nativeElement, 'visibility', visibilityStyle);
        }, this.transitionTime);
        this._isPickerVisible = !this._isPickerVisible;
    }
    _getClosestEl(el, selector) {
        for (; el && el !== document; el = el.parentNode) {
            if (el.matches && el.matches(selector)) {
                return el;
            }
        }
        return null;
    }
}
MdbColorPickerToggleDirective.ɵfac = function MdbColorPickerToggleDirective_Factory(t) { return new (t || MdbColorPickerToggleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
MdbColorPickerToggleDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbColorPickerToggleDirective, selectors: [["", "mdbColorPickerToggle", ""]], hostBindings: function MdbColorPickerToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function MdbColorPickerToggleDirective_click_HostBindingHandler($event) { return ctx.onClick($event); })("click", function MdbColorPickerToggleDirective_click_HostBindingHandler($event) { return ctx.onWindowClick($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { transitionTime: "transitionTime", mdbColorPickerToggle: "mdbColorPickerToggle" } });
MdbColorPickerToggleDirective.ctorParameters = () => [
    { type: Renderer2 }
];
MdbColorPickerToggleDirective.propDecorators = {
    mdbColorPickerToggle: [{ type: Input }],
    transitionTime: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onWindowClick: [{ type: HostListener, args: ['window:click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPickerToggleDirective, [{
        type: Directive,
        args: [{ selector: '[mdbColorPickerToggle]' }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, { transitionTime: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onWindowClick: [{
            type: HostListener,
            args: ['window:click', ['$event']]
        }], mdbColorPickerToggle: [{
            type: Input
        }] }); })();

class MdbColorPickerModule {
}
MdbColorPickerModule.ɵfac = function MdbColorPickerModule_Factory(t) { return new (t || MdbColorPickerModule)(); };
MdbColorPickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbColorPickerModule });
MdbColorPickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        MdbColorPickerService
    ], imports: [[
            CommonModule,
            FormsModule,
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbColorPickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    MdbColorPickerComponent,
                    MdbColorSliderComponent,
                    MdbColorPaletteComponent,
                    MdbColorDraggableDirective,
                    MdbColorPickerToggleDirective,
                    MdbColorPickerAlphaSliderComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                ],
                exports: [
                    MdbColorPickerComponent,
                    MdbColorSliderComponent,
                    MdbColorPaletteComponent,
                    MdbColorDraggableDirective,
                    MdbColorPickerToggleDirective,
                    MdbColorPickerAlphaSliderComponent
                ],
                providers: [
                    MdbColorPickerService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbColorPickerModule, { declarations: function () { return [MdbColorPickerComponent, MdbColorSliderComponent, MdbColorPaletteComponent, MdbColorDraggableDirective, MdbColorPickerToggleDirective, MdbColorPickerAlphaSliderComponent]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [MdbColorPickerComponent, MdbColorSliderComponent, MdbColorPaletteComponent, MdbColorDraggableDirective, MdbColorPickerToggleDirective, MdbColorPickerAlphaSliderComponent]; } }); })();

/*
 * Public API Surface of mdb-color-picker
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbColorDraggableDirective, MdbColorPaletteComponent, MdbColorPickerAlphaSliderComponent, MdbColorPickerComponent, MdbColorPickerModule, MdbColorPickerService, MdbColorPickerToggleDirective, MdbColorSliderComponent, RANGE_VALUE_ACCESOR };

//# sourceMappingURL=mdb-color-picker.js.map