import { EventEmitter, Directive, Renderer2, ElementRef, NgZone, Input, Output, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
class MdbTableEditorDirective {
    constructor(renderer, el, ngZone) {
        this.renderer = renderer;
        this.el = el;
        this.ngZone = ngZone;
        this.itemsPerPage = 10;
        this.rowHighlight = new EventEmitter();
        this.highlightedTableRow = null;
        this.dataArrayUnmodified = [];
        this.currentPage = 1;
        this.nextShouldBeDisabled = false;
        this.data = [];
        this.isDesc = true;
        this._searchKey = '';
        this._dataArray$ = new Subject();
        this._iterableDataArray = [];
        this._iterableDataArray$ = new Subject();
        this.paginationInfo = {
            firstItem: 1,
            lastItem: this.itemsPerPage,
            allItems: this.dataArrayUnmodified.length,
            activePage: this.currentPage,
        };
        this.dataArrayChange()
            .pipe()
            .subscribe((newData) => {
            this.dataArrayUnmodified = newData;
            setTimeout(() => {
                this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
                this.data = this.iterableDataArray;
                this.updatePaginationInfo();
            }, 0);
        });
        this.iterableDataArrayChange()
            .pipe(distinctUntilChanged())
            .subscribe(() => {
            if (this.data && this._searchKey.length == 0 && this.currentPage == 1) {
                this.paginationInfo.firstItem = this.data.findIndex((el) => el === this.data[0]) + 1;
                this.paginationInfo.lastItem =
                    this.data.findIndex((el) => el == this.data[this.data.length - 1]) + 1;
            }
            if (this.iterableDataArray &&
                this.iterableDataArray.findIndex((el) => el == this.highlightedTableRow) === -1) {
                if (this.highlightedTableRow !== null) {
                    this.highlightedTableRow = null;
                    this.rowHighlight.emit(null);
                }
            }
        });
        const click$ = fromEvent(this.el.nativeElement, 'click');
        click$.subscribe((event) => {
            // Workaround for situation when fromEvent is not able to emit value from EventEmitter
            this.ngZone.run(() => {
                this.markHighlightAndEmit(event);
            });
        });
    }
    set dataArray(data) {
        this._dataArray = data;
        this._dataArray$.next(this.dataArray);
    }
    get dataArray() {
        return this._dataArray;
    }
    dataArrayChange() {
        return this._dataArray$;
    }
    set iterableDataArray(data) {
        this._iterableDataArray = data;
        this._iterableDataArray$.next(this.iterableDataArray);
    }
    get iterableDataArray() {
        return this._iterableDataArray;
    }
    iterableDataArrayChange() {
        return this._iterableDataArray$;
    }
    ngOnChanges(changes) {
        if (changes['itemsPerPage']) {
            this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
            if (!changes['itemsPerPage'].isFirstChange()) {
                this.updatePaginationInfo();
            }
        }
    }
    calculatePagesNumber() {
        return Math.ceil(this.dataArrayUnmodified.length / this.itemsPerPage);
    }
    updatePaginationInfo() {
        if (this.dataArray) {
            const firstAndLastIndexes = {
                first: this.dataArray.findIndex((el) => el === this.iterableDataArray[0]) + 1 ||
                    this.iterableDataArray.findIndex((el) => el === this.iterableDataArray[0]) + 1,
                last: this.dataArray.findIndex((el) => el === this.iterableDataArray[this.iterableDataArray.length - 1]) + 1 ||
                    this.iterableDataArray.findIndex((el) => el === this.iterableDataArray[this.iterableDataArray.length - 1]) + 1,
            };
            this.paginationInfo = {
                firstItem: firstAndLastIndexes.first,
                lastItem: firstAndLastIndexes.last,
                allItems: this.dataArrayUnmodified.length,
                activePage: this.currentPage,
            };
        }
    }
    nextPage(switchToLastPage) {
        if (this.currentPage < this.calculatePagesNumber()) {
            if (switchToLastPage) {
                this.currentPage = this.calculatePagesNumber();
            }
            else {
                this.currentPage++;
            }
            this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
            this.updatePaginationInfo();
            const firstAndLastIndexes = {
                first: this.dataArrayUnmodified.findIndex((el) => el == this.iterableDataArray[0]) + 1,
                last: this.dataArrayUnmodified.findIndex((el) => el == this.iterableDataArray[this.iterableDataArray.length - 1]) + 1,
            };
            this.paginationInfo.firstItem = firstAndLastIndexes.first;
            this.paginationInfo.lastItem = firstAndLastIndexes.last;
        }
    }
    prevPage(switchToFirstPage) {
        if (this.currentPage > 1) {
            if (switchToFirstPage) {
                this.currentPage = 1;
            }
            else {
                this.currentPage--;
            }
            this.iterableDataArray = this.dataArrayUnmodified.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
            this.updatePaginationInfo();
        }
        const firstAndLastIndexes = {
            first: this.dataArrayUnmodified.findIndex((el) => el == this.iterableDataArray[0]) + 1,
            last: this.dataArrayUnmodified.findIndex((el) => el == this.iterableDataArray[this.iterableDataArray.length - 1]) + 1,
        };
        this.paginationInfo.firstItem = firstAndLastIndexes.first;
        this.paginationInfo.lastItem = firstAndLastIndexes.last;
    }
    disablePrevious() {
        return this.currentPage === 1;
    }
    disableNext() {
        if (this.dataArrayUnmodified) {
            return this.currentPage >= this.calculatePagesNumber() || this.nextShouldBeDisabled;
        }
    }
    filterIterableArray(searchKey) {
        if (this.dataArray) {
            const filter = this.dataArray.filter((obj) => {
                return Object.keys(obj).some((key) => {
                    if (obj[key] !== null) {
                        return obj[key]
                            .toString()
                            .toLowerCase()
                            .includes(searchKey);
                    }
                });
            });
            this.iterableDataArray = filter.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
            this.nextShouldBeDisabled = this.iterableDataArray.length < this.itemsPerPage;
            this.updatePaginationInfo();
            return this.iterableDataArray;
        }
    }
    performSearch(searchKey) {
        this._searchKey = searchKey;
        if (!searchKey && this.dataArray) {
            this.nextShouldBeDisabled = false;
            this.data = this.dataArray.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
            this._iterableDataArray$.next(this.data);
            return this.dataArray.slice(this.itemsPerPage * (this.currentPage - 1), this.itemsPerPage * (this.currentPage - 1) + this.itemsPerPage);
        }
        else {
            this.data = this.filterIterableArray(searchKey.toLowerCase());
            return this.filterIterableArray(searchKey.toLowerCase());
        }
    }
    sortArray(property) {
        this.dataArray = this.dataArrayUnmodified.slice();
        this.isDesc = !this.isDesc; //change the direction
        property = property.replace(/ /g, '_').toLowerCase();
        const direction = this.isDesc ? 1 : -1;
        this.dataArray.sort((a, b) => {
            if (a[property] < b[property]) {
                return -1 * direction;
            }
            else if (a[property] > b[property]) {
                return 1 * direction;
            }
            else {
                return 0;
            }
        });
    }
    _getClosestEl(el, selector) {
        for (; el && el !== document; el = el.parentNode) {
            if (el.matches && el.matches(selector)) {
                return el;
            }
        }
        return null;
    }
    markHighlightAndEmit(event) {
        const tableRow = this._getClosestEl(event.target, 'tr');
        const tbody = this._getClosestEl(event.target, 'tbody');
        if (tbody && event.target) {
            tbody.childNodes.forEach((row, index) => {
                if (row === tableRow) {
                    this.highlightedTableRow = this.iterableDataArray[index];
                }
                if (row !== tableRow) {
                    if (row.classList && row.classList.contains('tr-color-selected')) {
                        this.renderer.removeClass(row, 'tr-color-selected');
                    }
                }
            });
            this.rowHighlight.emit(this.highlightedTableRow);
            this.renderer.addClass(tableRow, 'tr-color-selected');
        }
    }
}
MdbTableEditorDirective.ɵfac = function MdbTableEditorDirective_Factory(t) { return new (t || MdbTableEditorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MdbTableEditorDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbTableEditorDirective, selectors: [["", "mdbTableEditor", ""]], inputs: { itemsPerPage: "itemsPerPage" }, outputs: { rowHighlight: "rowHighlight" }, exportAs: ["mdbEditor"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
MdbTableEditorDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone }
];
MdbTableEditorDirective.propDecorators = {
    itemsPerPage: [{ type: Input }],
    rowHighlight: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbTableEditorDirective, [{
        type: Directive,
        args: [{
                selector: '[mdbTableEditor]',
                exportAs: 'mdbEditor'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { itemsPerPage: [{
            type: Input
        }], rowHighlight: [{
            type: Output
        }] }); })();

class MdbTableEditorModule {
}
MdbTableEditorModule.ɵfac = function MdbTableEditorModule_Factory(t) { return new (t || MdbTableEditorModule)(); };
MdbTableEditorModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbTableEditorModule });
MdbTableEditorModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbTableEditorModule, [{
        type: NgModule,
        args: [{
                declarations: [MdbTableEditorDirective],
                imports: [CommonModule],
                exports: [MdbTableEditorDirective],
                providers: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbTableEditorModule, { declarations: function () { return [MdbTableEditorDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [MdbTableEditorDirective]; } }); })();

/*
 * Public API Surface of mdb-table-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbTableEditorDirective, MdbTableEditorModule };

//# sourceMappingURL=mdb-table-editor.js.map